import cirq
import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
from cirq.circuits import InsertStrategy
import scipy
from scipy import linalg
from cirq import protocols
from cirq.testing import gate_features
import random


unit = np.array([np.array([-6.64425723e-01-2.41227341e-01j, -9.47973080e-06-1.27809653e-03j,
       -1.31957744e-17-2.19306996e-18j, -7.24143545e-05+2.06983417e-04j,
        6.30511427e-06-6.11774295e-05j,  5.79827532e-19+5.61115801e-19j,
       -9.88693459e-03-1.25362875e-02j, -7.80789457e-03-6.25318600e-04j,
        1.95053508e-17+1.08138761e-16j, -6.64546277e-01-2.41155109e-01j,
       -1.50892637e-05-1.21210651e-03j, -1.41116811e-17-2.03290577e-18j,
       -3.52308462e-05+9.91032228e-05j,  1.23732349e-05-1.26178733e-04j,
       -5.39116336e-19-5.62267149e-19j,  1.19012677e-02+6.90571554e-03j,
        7.81809443e-03+6.25190718e-04j, -1.94946301e-17-1.08034326e-16j,
       -7.39970330e-17-1.32439830e-17j, -4.98653696e-20-7.89529016e-19j,
       -9.84944455e-33+2.59552035e-33j,  3.15606648e-19-1.04414294e-18j,
        2.20138490e-20-6.36292013e-19j,  8.76182723e-33-1.94216671e-33j,
        2.13320643e-17-1.06155572e-16j,  6.95437312e-19-3.16020595e-20j,
       -4.20463822e-33-9.76402415e-33j]), np.array([ 2.71826876e-04-1.18151385e-03j, -7.02633971e-01-7.76109911e-02j,
        2.47613633e-17+1.55630511e-16j,  4.17000973e-05-1.19360526e-04j,
       -1.08194183e-05+1.04614698e-04j,  2.47225883e-19-1.15684099e-18j,
        7.42892084e-03+2.44701462e-03j,  1.31933264e-02+3.90527875e-03j,
       -1.52185808e-18-2.78086120e-18j,  2.92845349e-04-1.24425076e-03j,
       -7.02616672e-01-7.77296217e-02j,  2.47843887e-17+1.55621882e-16j,
        2.05259361e-05-5.78046309e-05j, -2.14759041e-05+2.18244573e-04j,
       -3.17927923e-19+1.16522332e-18j, -7.41982167e-03-2.44513160e-03j,
       -1.25654949e-02-9.84986347e-03j,  2.78860303e-18+2.57273396e-18j,
        1.36549443e-19-7.71579752e-19j, -7.41152671e-17+4.54978193e-18j,
        5.51545339e-33+1.62142921e-32j, -1.74949052e-19+6.31625411e-19j,
       -6.23542353e-20+1.05371086e-18j, -8.81172966e-33+2.57160628e-33j,
       -6.59778311e-19-1.26245633e-19j,  4.29826985e-18+1.08820456e-16j,
        2.29420277e-32-7.24814679e-33j]), np.array([-3.27313866e-17+1.56456544e-16j,  1.01279841e-19+1.03222240e-20j,
        6.98395434e-01-1.09650974e-01j,  1.82372037e-19+7.24241504e-20j,
       -7.44987079e-19-2.12941378e-18j,  3.62530174e-05+2.16285750e-04j,
       -1.86029300e-17+5.80953815e-17j,  1.60698452e-20+8.26356104e-22j,
       -1.27649501e-02+5.25449802e-03j, -3.22425412e-17+1.56619922e-16j,
        1.01280539e-19+1.02997748e-20j,  6.98369100e-01-1.09756479e-01j,
       -2.53541375e-19-8.62041856e-20j,  7.45243481e-19+2.12982023e-18j,
        1.68670834e-05+1.03829103e-04j,  1.72788328e-17-5.83672657e-17j,
        1.04406992e-20+2.10595781e-21j,  1.18095767e-02-1.11587824e-02j,
        4.14816938e-33+1.83732582e-32j,  1.10601802e-35+5.96517879e-37j,
        7.29030058e-17-2.46287751e-17j, -4.86551352e-33-1.35567522e-33j,
       -1.63726383e-32+8.61354359e-34j,  2.80297319e-19+1.09217687e-18j,
       -2.30563669e-32-7.76741303e-33j, -3.19492652e-34+7.88574102e-35j,
       -3.21116120e-17-1.02117562e-16j]), np.array([-3.67405643e-03-1.55536484e-02j, -8.58100662e-04+7.79685355e-03j,
       -5.57828447e-17+8.65380285e-18j,  1.08105328e-02+3.84913217e-03j,
        5.74347002e-08+1.02387594e-05j,  1.67054826e-19-8.01780447e-20j,
       -2.25055455e-01+6.69977544e-01j,  1.34026391e-03-3.40482841e-05j,
       -1.20744590e-18-1.24672735e-17j,  1.98134949e-03-1.36229461e-02j,
       -8.58412632e-04+7.78570266e-03j, -5.56787817e-17+8.64391480e-18j,
        5.19800612e-03+1.88016948e-03j,  2.18473659e-07+2.12568985e-05j,
        1.22131188e-19+1.10672591e-19j,  2.25220584e-01-6.70091293e-01j,
       -1.40612763e-03+2.71075099e-05j,  1.27813049e-18+1.29412962e-17j,
        5.75093106e-17+1.03187235e-17j,  5.47669263e-20+9.31680091e-19j,
       -4.83996007e-33+1.65876082e-33j, -5.70990435e-17-1.61721436e-17j,
        7.36131187e-21+1.06455962e-19j, -1.00163389e-33+2.23104116e-34j,
        1.51933413e-17-7.73906500e-17j,  1.05947629e-18-3.82969915e-20j,
        3.02715236e-33+9.41866704e-33j]), np.array([-2.66511762e-03+7.34255693e-03j, -1.28592254e-03-1.37049430e-02j,
       -3.09902038e-18-1.24339366e-19j, -4.81036046e-06+2.07057931e-05j,
        5.49448070e-03+6.01119923e-04j, -5.69920653e-17+1.15537397e-17j,
       -1.37238808e-03-3.05789853e-04j,  6.08191926e-02-7.04264243e-01j,
       -1.53052887e-16+2.89230196e-17j, -2.66787816e-03+7.35429760e-03j,
       -7.24067417e-03-1.42494535e-02j, -3.32637804e-18-1.42149266e-18j,
       -2.36391686e-06+9.96335442e-06j,  1.14140508e-02+1.19107746e-03j,
        5.75831511e-17-7.82400171e-18j,  1.31031575e-03+2.83597341e-04j,
       -6.07035513e-02+7.04197972e-01j,  1.53450979e-16-2.63305721e-17j,
       -1.68207929e-19+9.24818707e-19j,  5.89961290e-17-3.56122371e-18j,
       -4.03475602e-33-1.19135006e-32j,  1.82614279e-20-1.08611370e-19j,
        5.74462349e-17+2.33877306e-18j, -3.60295606e-33+1.40784562e-32j,
       -1.03232355e-18-2.11787698e-19j,  3.32784821e-18+8.08964161e-17j,
        1.52652481e-32-1.40550976e-32j]), np.array([ 9.87472400e-17+3.52669015e-17j,  4.17588028e-21+2.31341175e-21j,
       -7.66288659e-04+1.37848410e-02j, -4.95771303e-19+2.51948756e-18j,
       -1.07641077e-16-7.87909033e-18j,  1.13264997e-02-1.84672755e-03j,
        1.53940734e-16+2.86071599e-17j,  6.82263419e-20-8.38796870e-19j,
        1.26057114e-01+6.95526718e-01j,  9.89977534e-17+3.39678386e-17j,
        2.97338315e-21+2.21590890e-21j, -6.65375325e-03+1.48219297e-02j,
       -2.42558944e-19+1.20597252e-18j,  1.07660791e-16+7.88148361e-18j,
        5.46029264e-03-8.62209058e-04j, -1.54254021e-16-2.77753640e-17j,
        4.67129837e-20-5.54239448e-19j, -1.25950534e-01-6.95608958e-01j,
        1.16211289e-32-1.05079347e-32j,  6.07683603e-35+2.12915317e-36j,
       -5.41016090e-17+1.83383585e-17j, -1.64647774e-33+1.24986553e-32j,
       -1.23057517e-32+6.95463372e-34j,  5.54600765e-17-1.26230910e-17j,
       -2.10424195e-32+1.54132285e-32j, -2.82814061e-34+1.63677791e-32j,
       -2.47201142e-17-7.76628278e-17j]), np.array([ 4.75251982e-05-1.34874766e-04j, -2.53288500e-07-2.71977589e-08j,
       -1.08935922e-19-6.92880259e-19j,  2.38699481e-01-6.65476700e-01j,
        1.29378976e-03+1.37955013e-04j,  1.24484680e-18-1.20185659e-17j,
       -1.08703717e-02-3.68269128e-03j, -8.48379832e-07+1.01393129e-05j,
        2.36336567e-19+2.11143528e-19j,  7.14029130e-06-2.09343151e-05j,
        5.55807958e-07+5.73124905e-08j, -1.09124525e-19-6.90760333e-19j,
        2.38742530e-01-6.65582167e-01j,  1.29373501e-03+1.37959927e-04j,
        1.24258855e-18-1.20200935e-17j,  5.24534123e-03+1.74787522e-03j,
        1.86619563e-06-2.10351749e-05j, -7.83048085e-20+1.91241194e-19j,
       -9.92008990e-21+2.52527599e-19j, -4.93091319e-22+9.39055250e-23j,
       -2.25487091e-35-6.75489151e-35j, -1.44498026e-17+7.52020222e-17j,
       -1.43336137e-19+6.70522652e-21j,  5.12733442e-35+1.30969991e-33j,
        1.04809764e-16+3.08947222e-17j, -9.98529675e-21+1.97307077e-19j,
       -1.96043713e-33-3.00232289e-35j]), np.array([ 5.24581674e-07+1.91916675e-07j,  2.00755675e-06-2.20816986e-05j,
       -5.28066250e-20-4.53902041e-19j,  1.22456405e-03+4.39344724e-04j,
        7.50223300e-02-7.03071484e-01j,  1.54998014e-16-2.50103752e-17j,
        6.77709450e-06-1.99994765e-05j,  5.50927634e-03+4.61401048e-04j,
        1.06364604e-16-1.82123931e-17j, -2.37963321e-07-9.13141826e-08j,
        1.43829534e-05-1.42342268e-04j, -4.78118624e-20-4.54836409e-19j,
        1.22475813e-03+4.39423957e-04j,  7.50249984e-02-7.03041729e-01j,
        1.55239504e-16-2.36321547e-17j, -3.21754673e-06+9.65324740e-06j,
       -1.14329471e-02-1.01520688e-03j,  1.07038864e-16-1.44966056e-17j,
       -4.32715470e-22-1.15182612e-23j,  5.01612933e-20+2.50226037e-19j,
        2.58639994e-34-1.79770120e-35j, -1.38383415e-19-2.66009221e-20j,
        3.63778686e-18+7.78929393e-17j, -1.47018558e-32+1.39237215e-32j,
       -5.68667802e-20+1.92864732e-19j,  1.07220894e-16+5.43453109e-18j,
        6.39486194e-33-2.66634262e-32j]), np.array([-4.29997237e-19+1.22344157e-18j,  2.16035257e-20-2.44807895e-19j,
       -7.46055056e-06-4.53857238e-05j,  1.54875655e-16+3.08083710e-17j,
        1.41679149e-19-1.84945902e-18j, -1.12138103e-01-6.98042562e-01j,
       -4.70752183e-19+2.51756384e-18j, -5.79176032e-17-4.82072581e-18j,
       -1.12986694e-02+2.02139663e-03j, -4.25023172e-19+1.22450642e-18j,
        2.16086283e-20-2.44843878e-19j, -1.14969923e-05-6.79559645e-05j,
        1.54900371e-16+3.08144063e-17j, -4.93326620e-20+7.40296444e-19j,
       -1.12151304e-01-6.98155710e-01j,  2.18236854e-19-1.21459627e-18j,
       -5.79244512e-17-4.82171408e-18j,  5.43717797e-03-1.00080505e-03j,
        2.27149937e-34+1.58747814e-34j,  1.75520977e-36+2.70953022e-35j,
       -2.97451667e-19-1.09873913e-18j, -1.72903772e-32-7.40483588e-34j,
       -1.90225716e-34+4.58581923e-33j,  2.38469965e-17+7.37225376e-17j,
       -3.55348281e-33+2.35495458e-32j, -6.42921215e-33+4.48134155e-34j,
       -1.04223664e-16+2.26749216e-17j]), np.array([-2.41250028e-01+6.64462448e-01j, -1.27815509e-03+9.46616218e-06j,
       -2.19334544e-18+1.31966645e-17j,  2.06456828e-04+7.21436911e-05j,
       -6.11810726e-05-6.30512067e-06j,  5.61146315e-19-5.79856649e-19j,
       -1.25356172e-02+9.88789323e-03j, -6.25452813e-04+7.80835034e-03j,
        1.08145436e-16-1.95051735e-17j,  2.41148903e-01-6.64503581e-01j,
        1.21205214e-03-1.50715833e-05j,  2.03297904e-18-1.41106845e-17j,
       -9.96851617e-05-3.53929381e-05j,  1.26171205e-04+1.23751689e-05j,
        5.62230267e-19-5.39076633e-19j, -6.90699114e-03+1.18999479e-02j,
       -6.25250190e-04+7.81762273e-03j,  1.08028141e-16-1.94921291e-17j,
        1.61444691e-17-7.75719939e-17j, -4.85920950e-19+2.54039259e-21j,
        2.74374727e-33+7.30203187e-33j,  8.67425415e-19+1.20675295e-18j,
        6.37434613e-19+2.17694071e-20j,  1.91676553e-33+8.78474163e-33j,
       -1.06019011e-16-1.83530674e-17j,  9.67378019e-20+1.04423668e-18j,
        1.26855519e-32-3.83414908e-33j]), np.array([-1.18156420e-03-2.71851747e-04j, -7.76243694e-02+7.02675002e-01j,
        1.55640119e-16-2.47609070e-17j, -1.19366745e-04-4.17051175e-05j,
        1.05222481e-04+1.09262494e-05j, -1.15689096e-18-2.47259623e-19j,
        2.44725222e-03-7.42933131e-03j,  3.90405350e-03-1.31942115e-02j,
       -2.78097530e-18+1.52235994e-18j,  1.24418967e-03+2.92849343e-04j,
        7.77336513e-02-7.02573706e-01j, -1.55612892e-16+2.47809866e-17j,
        5.78010977e-05+2.05243095e-05j, -2.17625960e-04-2.14976116e-05j,
       -1.16520160e-18-3.18185875e-19j,  2.44507810e-03-7.41935099e-03j,
        9.85105101e-03-1.25644773e-02j, -2.57265211e-18+2.78814111e-18j,
       -4.79729781e-19-1.13224354e-19j, -2.66231074e-18-8.00967915e-17j,
       -1.65214978e-32+5.11094202e-33j, -6.34230114e-19-1.75294100e-19j,
       -1.08961489e-18-9.70095578e-19j,  2.40335672e-33+8.22299743e-33j,
        1.43346313e-19-1.00362842e-18j,  1.06685425e-16-7.19294173e-18j,
       -8.05741617e-33-2.27035602e-32j]), np.array([ 1.56465571e-16+3.27350546e-17j,  1.03238889e-20-1.01285826e-19j,
       -1.09648839e-01-6.98438528e-01j,  7.24740238e-20-1.82510450e-19j,
       -2.12956925e-18+7.45253134e-19j,  2.15684862e-04-3.62344765e-05j,
        5.80986897e-17+1.86044073e-17j,  8.16192730e-22-1.60217766e-20j,
        5.25625714e-03+1.27654924e-02j, -1.56610084e-16-3.22427831e-17j,
       -1.03006252e-20+1.01274340e-19j,  1.09741299e-01+6.98328743e-01j,
        8.62179516e-20-2.53656771e-19j, -2.12968340e-18+7.44924806e-19j,
       -1.04408020e-04+1.70045963e-05j,  5.83634987e-17+1.72788785e-17j,
       -2.10660840e-21+1.04898383e-20j,  1.11563672e-02+1.18092944e-02j,
       -1.65293576e-32-5.69186840e-33j, -8.41187161e-37+1.22387160e-35j,
        2.27411098e-17+7.40419804e-17j,  1.15602525e-33-4.87623473e-33j,
        1.32509091e-33+1.65278230e-32j, -8.16752176e-19+1.14580572e-18j,
        5.46191798e-33+2.56767524e-32j, -1.84341603e-34-3.12633339e-34j,
       -1.02958685e-16+3.55296775e-17j]), np.array([-1.55551785e-02+3.67561229e-03j,  7.79730591e-03+8.58248627e-04j,
        8.65362357e-18+5.57863159e-17j,  3.84950153e-03-1.08111414e-02j,
        1.02405333e-05-6.39922417e-08j, -8.01308023e-20-1.67070992e-19j,
        6.70014764e-01+2.25077231e-01j, -3.40353114e-05-1.34032640e-03j,
       -1.24677836e-17+1.20731787e-18j,  1.36215480e-02+1.98292735e-03j,
       -7.78522956e-03-8.58457769e-04j, -8.64271301e-18-5.56755292e-17j,
       -1.88011845e-03+5.19766097e-03j, -2.12558582e-05+2.11476286e-07j,
       -1.10622348e-19+1.22111249e-19j,  6.70048475e-01+2.25215402e-01j,
       -2.70868623e-05-1.40606197e-03j, -1.29407861e-17+1.27793902e-18j,
        1.30925360e-17-5.63271322e-17j, -7.84138708e-19+2.62037468e-20j,
       -2.11061427e-33-6.85341025e-33j,  1.61743562e-17-5.71866086e-17j,
       -1.16497370e-19+7.76428015e-21j, -5.76262620e-35-1.12938900e-33j,
        7.31905905e-17+1.01285706e-17j, -8.99846937e-20-1.32581382e-18j,
        7.00115992e-33-2.37764556e-33j]), np.array([ 7.34295997e-03+2.66536727e-03j, -1.37059422e-02+1.28744947e-03j,
       -1.24027429e-19+3.09914710e-18j,  2.07038986e-05+4.81686342e-06j,
        6.01221960e-04-5.49479013e-03j,  1.15537237e-17+5.69956138e-17j,
       -3.05819333e-04+1.37244920e-03j, -7.04305567e-01-6.08315864e-02j,
        2.89228429e-17+1.53062395e-16j, -7.35382793e-03-2.66781055e-03j,
        1.42485226e-02-7.23844843e-03j,  1.42180682e-18-3.32621750e-18j,
       -9.96453429e-06-2.35738464e-06j, -1.19114741e-03+1.14133655e-02j,
        7.82282575e-18+5.75798074e-17j, -2.83602426e-04+1.31025101e-03j,
       -7.04155162e-01-6.07086218e-02j,  2.63271013e-17+1.53442130e-16j,
       -7.54756255e-19-1.57258658e-19j, -5.02301770e-19-5.71908138e-17j,
       -1.25103169e-32+3.61329737e-33j,  1.18682206e-19+2.02625418e-20j,
       -2.32266079e-18+5.73988634e-17j, -1.42803925e-32-3.15275694e-33j,
       -2.25532180e-19+1.30810776e-18j, -7.66019233e-17+7.29852846e-18j,
        1.44626174e-32+1.34995993e-32j]), np.array([ 3.52705930e-17-9.87526287e-17j,  2.31293095e-21-4.17638914e-21j,
        1.37854028e-02+7.64898113e-04j,  2.51971828e-18+4.95870828e-19j,
       -7.88090022e-18+1.07647413e-16j, -1.84669776e-03-1.13272112e-02j,
        2.86109113e-17-1.53949536e-16j, -8.38847087e-19-6.82410185e-20j,
        6.95569857e-01-1.26055998e-01j, -3.39666755e-17+9.89914920e-17j,
       -2.21648405e-21+2.97289016e-21j, -1.48212091e-02-6.65514703e-03j,
       -1.20580453e-18-2.42535753e-19j, -7.88234195e-18+1.07654258e-16j,
        8.62087233e-04+5.45996587e-03j,  2.77754815e-17-1.54244499e-16j,
        5.54204803e-19+4.67170443e-20j,  6.95568926e-01-1.25934414e-01j,
       -1.53304544e-32+1.08644369e-32j, -1.39810934e-36+7.74595019e-35j,
        1.61478213e-17+5.68263722e-17j, -1.24508010e-32-1.78504936e-33j,
       -1.27128664e-33-1.12761032e-32j,  1.25798035e-17+5.53758476e-17j,
        1.60079415e-32-1.35790957e-32j, -1.63601247e-32-2.85305956e-34j,
        6.97232586e-17-2.65404179e-17j]), np.array([-1.35144424e-04-4.69770271e-05j, -2.61171153e-08+2.53530421e-07j,
       -6.92925081e-19+1.08944586e-19j, -6.65513510e-01-2.38721994e-01j,
        1.37979292e-04-1.29386537e-03j, -1.20192687e-17-1.24506955e-18j,
       -3.68305296e-03+1.08709725e-02j,  1.01399091e-05+8.48551803e-07j,
        2.11159205e-19-2.36348049e-19j,  2.07782280e-05+7.72248481e-06j,
       -5.61906284e-08+5.55799717e-07j,  6.90720337e-19-1.09098662e-19j,
        6.65539435e-01+2.38736512e-01j, -1.37967716e-04+1.29365599e-03j,
        1.20193600e-17+1.24266384e-18j, -1.74783342e-03+5.24500670e-03j,
        2.10338946e-05+1.86635872e-06j, -1.91228836e-19-7.83024997e-20j,
        1.11686425e-18+2.71762637e-19j, -3.21368979e-24+2.07710602e-21j,
        9.29857861e-35-2.40370268e-35j, -8.05984901e-17-1.56612856e-17j,
       -6.88165392e-21-1.53513711e-19j, -1.40334777e-33+5.29268320e-35j,
       -3.08770818e-17+1.04720602e-16j, -1.97342746e-19-9.98538814e-21j,
        9.61053201e-35-1.75582655e-33j]), np.array([ 1.90917646e-07-5.25093194e-07j, -2.19595242e-05-2.59777848e-06j,
       -4.53796241e-19+5.27965113e-20j,  4.39386156e-04-1.22463179e-03j,
       -7.03112570e-01-7.50355274e-02j, -2.50099488e-17-1.55007587e-16j,
       -2.00005818e-05-6.77776002e-06j,  4.61494515e-04-5.50960030e-03j,
       -1.82121631e-17-1.06371186e-16j,  9.02400474e-08-2.38232816e-07j,
        1.42347587e-04+1.37723295e-05j,  4.54941699e-19-4.78357233e-20j,
       -4.39412877e-04+1.22467949e-03j,  7.02998787e-01+7.50292278e-02j,
        2.36288186e-17+1.55230519e-16j, -9.65263174e-06-3.21746974e-06j,
        1.01529546e-03-1.14322512e-02j,  1.44944125e-17+1.07032646e-16j,
       -5.07270331e-22+2.08849291e-21j,  1.14721314e-18+9.32814918e-22j,
       -7.79774654e-35-3.65051997e-35j,  2.88309171e-20-1.48313151e-19j,
       -8.34233740e-17+3.73321921e-18j, -1.42659213e-32-1.58815091e-32j,
       -1.92700673e-19-5.68343093e-20j, -5.43458282e-18+1.07240264e-16j,
        2.69093616e-32+7.20254566e-33j]), np.array([ 1.22363809e-18+4.30077418e-19j, -2.44822240e-19-2.16079419e-20j,
       -4.54242101e-05+6.85881661e-06j,  3.08121312e-17-1.54884528e-16j,
       -1.84956793e-18-1.41709786e-19j, -6.98085667e-01+1.12136153e-01j,
        2.51770860e-18+4.70810996e-19j, -4.82173174e-18+5.79210046e-17j,
        2.02137982e-03+1.12993695e-02j, -1.22429224e-18-4.24997549e-19j,
        2.44828981e-19+2.16102715e-20j,  6.78050604e-05-1.20891666e-05j,
       -3.08144849e-17+1.54890734e-16j, -7.40251597e-19-4.93396532e-20j,
        6.98115380e-01-1.12135950e-01j,  1.21452082e-18+2.18240546e-19j,
        4.82214379e-18-5.79209301e-17j,  1.00067053e-03+5.43686736e-03j,
       -1.48995151e-34-8.57583811e-35j, -2.92178991e-35+1.83246352e-36j,
       -2.35695287e-19+1.16493123e-19j,  8.31972921e-34-1.85220980e-32j,
       -4.60180343e-33-1.89477174e-34j, -7.90335131e-17+2.53905617e-17j,
       -2.36438767e-32-3.16493945e-33j, -4.66548814e-34-6.88348285e-33j,
       -2.27042265e-17-1.04320131e-16j]), np.array([-2.21280532e-18-2.49209616e-18j,  1.69171983e-18-5.29696385e-20j,
       -6.77648195e-33-2.27449270e-32j, -7.33224233e-20+3.38013107e-19j,
        1.14956432e-21-1.28474617e-22j,  1.75259237e-35+3.26971421e-36j,
       -8.05726457e-17-1.58519495e-17j,  2.94725525e-20+2.09017292e-19j,
        2.46236003e-33-3.09730749e-34j, -2.29357272e-17-6.06947513e-18j,
       -4.16661136e-21-4.04674224e-20j, -4.78168605e-34-2.57663432e-35j,
       -3.04506676e-18+9.60982805e-19j, -1.67209835e-18+2.28803423e-19j,
       -9.18275281e-33-2.18484010e-32j,  4.21239236e-19+1.69881899e-19j,
        2.64099613e-19+4.56430599e-21j, -9.51950156e-34-3.64284492e-33j,
        7.28861692e-02-9.97085886e-01j,  1.91513171e-03-5.36728886e-04j,
       -1.00248498e-18-1.64914542e-17j,  3.09118227e-04+1.89959472e-05j,
       -8.56911990e-05+1.49113741e-05j, -1.10761817e-18-2.33904299e-19j,
        3.16613204e-03+1.92673779e-02j,  2.13822747e-03+1.08376812e-02j,
        1.39435334e-16-6.79734534e-17j]), np.array([ 1.65364945e-18+3.47277155e-19j, -2.71105999e-18-1.20584595e-18j,
        1.09659673e-34+5.91381912e-34j,  4.10493197e-22+1.16397113e-22j,
       -1.11862403e-20-3.45578672e-19j, -1.98030425e-33-6.45390445e-33j,
        1.78528257e-20-1.95903794e-19j,  8.20513735e-17-3.62116269e-18j,
       -5.57623119e-33-1.74560898e-32j,  5.99845767e-21-4.24752571e-20j,
       -2.37186045e-17-4.92735641e-19j,  1.29521252e-33+5.12716017e-33j,
        1.67516193e-18+1.65892364e-19j,  2.73362491e-18-1.64131706e-18j,
        5.24059569e-35+7.16390304e-34j, -2.56920702e-19-4.48820130e-20j,
       -4.51064412e-19-3.03783922e-19j,  1.96575897e-34+1.78626804e-34j,
        1.89417785e-03-7.35530411e-05j, -1.64476113e-01-9.86049474e-01j,
       -2.02340701e-16+9.33990061e-17j, -1.78477648e-04-1.09243183e-05j,
        1.46977877e-04-2.54904940e-05j,  1.17239799e-18-1.21909198e-18j,
        4.79602209e-04-1.10216730e-02j, -1.59545270e-02-1.65470491e-02j,
       -4.79995439e-18-2.15006747e-19j]), np.array([-2.87211062e-33+1.28469321e-32j,  3.97161372e-37+2.90638448e-37j,
        2.74731649e-18-1.76487759e-19j, -7.64517964e-35-2.83584893e-36j,
       -7.26517334e-34-1.25347464e-32j,  9.89321928e-20+3.31444981e-19j,
       -5.52503230e-34+1.86259726e-32j,  1.65897865e-35-7.26813509e-37j,
       -7.83056886e-17+2.50868220e-17j, -6.08402570e-34+5.33171422e-33j,
        4.47766197e-36+3.16804252e-37j,  2.30149538e-17-5.76151130e-18j,
       -1.61752792e-33+1.31319982e-32j,  2.70494079e-35+6.97512327e-35j,
        3.15547364e-18+2.59237560e-20j,  3.80099820e-34-2.00616469e-33j,
        6.43767595e-35-2.51258423e-34j,  3.71108909e-19-3.84857820e-19j,
       -2.25604777e-16+1.68085869e-17j,  2.50965329e-20+1.41758289e-19j,
        4.17125261e-01+9.08568120e-01j,  2.85506358e-20-2.76138041e-19j,
        3.08945696e-18+6.36225625e-19j,  2.80055573e-04-1.32270144e-04j,
        8.65482238e-17+6.62697475e-18j,  7.34746672e-21+2.73196628e-20j,
       -2.81784701e-03+2.24154205e-02j]), np.array([-3.22226507e-17+1.49233054e-16j, -2.94376078e-19+3.71042257e-20j,
        5.47497134e-34+2.54801703e-33j, -2.29280214e-20+9.36663546e-20j,
       -3.98624039e-21+1.33692329e-22j, -8.07500713e-35-3.24479678e-36j,
        4.31786722e-18-1.00883555e-18j, -4.14352100e-20-9.20822520e-19j,
        6.17514613e-33-1.95585601e-33j,  2.60992430e-20-4.66893773e-19j,
       -5.35774319e-21+2.62816858e-19j, -1.83518464e-33+4.55658359e-34j,
       -1.59448294e-17+1.51800612e-16j,  2.60469874e-19-6.66741403e-20j,
        7.84156266e-34+2.43751456e-33j,  4.19465950e-18-2.32245288e-17j,
       -4.71970682e-20+3.96171620e-21j,  1.10291187e-34+4.37255551e-34j,
        1.87424206e-02+5.45354745e-03j, -1.09704507e-02+1.83467704e-03j,
       -3.31915684e-17-7.23017882e-17j,  1.08781143e-03-1.61925769e-02j,
        1.39136676e-05-4.01471651e-06j,  8.70302514e-20-3.54558648e-19j,
        9.98394712e-01+4.93688033e-02j, -5.28606813e-04-1.63115832e-03j,
       -1.53262216e-17+5.85520684e-18j]), np.array([-3.02379648e-19-3.50193779e-20j,  3.86562509e-18+1.52583839e-16j,
        3.22033350e-32-9.71320107e-33j,  3.63043175e-21+7.94650274e-22j,
        9.45011262e-21+4.62059046e-20j,  2.31357572e-34+3.33112074e-34j,
       -1.76414571e-19+8.99629716e-19j, -5.24922596e-18+2.03796732e-18j,
        8.22730201e-34+1.25055343e-33j, -6.71283662e-20+2.53820132e-19j,
       -2.85011159e-19-4.57306486e-19j, -1.24879194e-34-6.45698544e-35j,
       -2.68909766e-19+4.27877788e-21j, -1.97438291e-17-1.51333600e-16j,
        3.29430493e-32-1.33677225e-32j,  4.46485158e-20+3.08177087e-21j,
       -5.56958280e-19+2.37971697e-17j,  1.14278795e-32-3.60165223e-33j,
       -1.10487703e-02-8.06417667e-04j,  2.10437999e-02+9.19258870e-03j,
       -4.30117596e-18-2.71724718e-18j,  3.00294132e-05-1.39905910e-06j,
       -1.29172695e-03-7.70949358e-03j, -3.10654596e-17-7.61817333e-17j,
        1.21792648e-04+1.80357089e-03j, -9.81931607e-01+1.87338930e-01j,
        9.60183184e-17+1.98148497e-16j]), np.array([ 3.36990798e-32+2.44475643e-33j, -7.58108026e-37-2.19343045e-35j,
       -4.37867892e-17-1.46263056e-16j, -1.07183326e-35-5.36769437e-35j,
        3.37436555e-34+1.08236709e-33j,  2.51271372e-20+9.30993871e-20j,
        1.19714347e-32+9.20695040e-34j,  8.67837613e-36-4.69150447e-37j,
        5.69479545e-18-3.72105606e-18j,  3.41215889e-33+8.38711482e-34j,
       -7.86836817e-36-5.24034211e-35j, -1.80139438e-19+5.10157162e-19j,
        3.38474846e-32-1.62515521e-33j,  3.65339779e-33+1.64357568e-34j,
       -5.90090603e-17-1.40771287e-16j, -5.24956826e-33-7.64506801e-34j,
       -1.23978027e-32+1.92875732e-33j, -5.06072765e-18-2.33814820e-17j,
       -1.37724723e-17+1.48275221e-16j, -4.10469525e-21-6.83979714e-21j,
       -1.20179690e-02+1.91315124e-02j,  3.61978015e-18-2.92688449e-19j,
       -3.06585067e-17-1.49534189e-16j, -6.86309664e-03-1.47076139e-02j,
       -2.27545352e-17-2.20640854e-16j,  1.45019080e-18-2.85836479e-19j,
        8.98094594e-01-4.38921676e-01j]), np.array([-1.79495059e-18-3.89371795e-19j, -8.28293132e-23-3.37828317e-21j,
       -3.21586041e-35+1.34397609e-36j,  5.85384058e-18+1.02881156e-18j,
        7.01667543e-22+1.09150385e-20j,  1.01672249e-34-6.93367035e-36j,
       -1.03858098e-20+7.29045217e-20j,  7.16650645e-23-6.81324006e-24j,
        2.31343772e-35+7.66082061e-35j, -3.44822036e-19-4.26030056e-20j,
       -5.62743090e-23-6.36074067e-22j, -1.16146271e-35-2.20506357e-35j,
        1.50116922e-18-2.34753672e-17j,  4.35145815e-20-8.08252406e-22j,
       -5.64166660e-35-3.55304108e-34j, -9.31943316e-18+8.16915275e-17j,
       -1.50147582e-19+1.77519242e-20j, -1.77336041e-34-1.38732550e-33j,
       -6.48365629e-05-4.69576118e-06j, -1.03191701e-07-5.88131935e-07j,
        8.95741796e-19-4.15694457e-19j, -9.97458549e-01-6.93508866e-02j,
       -3.09052213e-04-1.81398350e-03j, -1.68357894e-17+2.92298565e-18j,
       -8.38356803e-04+1.62112297e-02j,  1.41188900e-05-2.73739908e-06j,
       -3.09224149e-19-1.58423708e-19j]), np.array([ 7.16584755e-22-3.30261025e-21j, -1.83562581e-18+4.49160648e-20j,
        1.21085733e-34+3.89300528e-34j, -1.89419395e-21+1.07727331e-20j,
        5.93194713e-18-3.80863621e-19j,  4.22169775e-34+1.25063483e-33j,
       -1.34177777e-22-1.91265113e-23j, -3.70054070e-21-3.89549985e-20j,
        2.60575421e-34+8.70444907e-34j,  6.87747520e-23-6.36349470e-22j,
       -3.45284399e-19+3.58875883e-20j, -3.26517271e-35-8.63161663e-35j,
        4.31987912e-20+2.76523144e-21j, -4.37119006e-19-2.36469664e-17j,
        2.69460252e-32-9.48066823e-33j, -1.50325921e-19-1.71609926e-20j,
        9.64047986e-18+8.15946471e-17j,  2.03521325e-32-7.91123295e-33j,
       -2.73534991e-08+2.97149940e-07j, -9.58355698e-05+1.75796087e-05j,
       -6.09123220e-19+2.21992347e-19j,  1.27759649e-04-1.83549492e-03j,
       -9.85776307e-01+1.67870637e-01j, -9.23963497e-17-2.01907481e-16j,
       -2.98331560e-05-1.54513707e-06j, -1.48748629e-03-7.67545183e-03j,
        5.91534567e-17+1.40936003e-16j]), np.array([-3.03580891e-35+4.08159454e-34j,  2.32334959e-36-1.78913181e-37j,
        1.75983218e-18-5.25342188e-19j, -3.38080980e-35+1.32720837e-33j,
       -1.61149791e-35+1.45344331e-36j,  5.62343212e-18-1.92432680e-18j,
       -5.73700526e-36+1.48290305e-34j, -4.26355063e-35-4.86696826e-34j,
        3.51039024e-20+9.77268020e-20j, -1.26501210e-35-3.53783377e-35j,
        8.98746574e-38-8.27417195e-36j, -3.22908560e-19+1.27575613e-19j,
        5.28201985e-33+6.64863953e-34j,  1.24337862e-32-1.67103471e-33j,
       -5.44141906e-18-2.31951208e-17j, -1.83427191e-32+5.49741182e-34j,
       -1.95672604e-33-1.15175295e-35j, -3.09024676e-17-7.61282984e-17j,
       -1.83559460e-18-1.74969279e-19j, -3.41490278e-19+6.45993841e-20j,
       -1.82848406e-04+8.65299147e-05j, -1.75395413e-17-2.22635561e-16j,
        2.28694866e-18-4.66179791e-19j, -9.07060161e-01+4.20687950e-01j,
        3.60899652e-18-3.56176999e-19j, -1.56783280e-17-8.06796170e-17j,
        7.08966904e-03+1.46016301e-02j])])

N = 5000
PMS1 = 0.999
PMS2 = 0.99

T0 = 25

zZ = np.array([[1, 0, 0]]).T
eE = np.array([[0, 1, 0]]).T
fF = np.array([[0, 0, 1]]).T
A = [zZ, eE, fF]

B = []
for i1 in range(3):
    for i2 in range(3):
        for i3 in range(3):
            for i4 in range(3):
                B.append(np.kron(np.kron(np.kron(A[i1], A[i2]), A[i3]), A[i4]))

X = np.array([[0, 1, 0], [1, 0, 0], [0, 0, 1]])
Y = np.array([[0, complex(0, -1), 0], [complex(0, 1), 0, 0], [0, 0, 1]])
Z = np.array([[1, 0, 0], [0, -1, 0], [0, 0, 1]])
id = np.eye(3)

z = np.array([[1, 0, 0]]).T
e = np.array([[0, 1, 0]]).T
f = np.array([[0, 0, 1]]).T
basis = [z, e, f]
paulies1 = [id, X, Y, Z]


def dag(matrix):
    return np.conj(matrix.T)


def EE(bas, i, j, p0, paulies, pinv):
    v1 = bas[i]
    v2 = bas[j]
    id = paulies[0]
    x = paulies[1]
    y = paulies[2]
    z = paulies[3]
    K0 = (1 - p0) ** 0.5 * id
    # K0 = id
    K1 = p0 ** 0.5 / 3 ** 0.5 * x
    # K1 = x
    K2 = p0 ** 0.5 / 3 ** 0.5 * y
    # K2 = y
    K3 = p0 ** 0.5 / 3 ** 0.5 * z
    # K3 = z
    # mat_sum = K0 @ dag(K0) + K1 @ dag(K1) + K2 @ dag(K2) + K3 @ dag(K3)
    # print(mat_sum)
    # print(np.trace(mat_sum))
    # print()
    # print(dag(K3))
    _rho = v1 @ (v2.T)
    # print(_rho)
    if i == 0 and j == 0:
        ksgfsg = 0
        # print('eij', K0 @ _rho @ dag(K0) + K1 @ _rho @ dag(K1) + K2 @ _rho @ dag(K2) + K3 @ _rho @ dag(K3))
    # print('ee', np.trace(K0 @ _rho @ dag(K0) + K1 @ _rho @ dag(K1) + K2 @ _rho @ dag(K2) + K3 @ _rho @ dag(K3)))
    # print()
    return (K0 @ _rho @ dag(K0) + K1 @ _rho @ dag(K1) + K2 @ _rho @ dag(K2) + K3 @ _rho @ dag(K3))


def E(bas, i, j, p0, paulies):
    v1 = bas[i]
    v2 = bas[j]
    id = paulies[0]
    x = paulies[1]
    y = paulies[2]
    z = paulies[3]
    # K0 = (1-p0)**0.5 * id
    K0 = id / 2
    # K1 = p0**0.5 / 3**0.5 * x
    K1 = x / 2
    # K2 = p0**0.5 / 3**0.5 * y
    K2 = y / 2
    # K3 = p0 ** 0.5 / 3**0.5 * z
    K3 = z / 2
    # mat_sum = K0 @ dag(K0) + K1 @ dag(K1) + K2 @ dag(K2) + K3 @ dag(K3)
    # print(mat_sum)
    # print()
    # print(dag(K3))
    _rho = v1 @ (v2.T)

    # print(_rho)
    if i == 0 and j == 0:
        cgjjjfjk = 0
    # print('e', np.trace(K0 @ _rho @ dag(K0) + K1 @ _rho @ dag(K1) + K2 @ _rho @ dag(K2) + K3 @ _rho @ dag(K3)))
    # print()
    return K0 @ _rho @ dag(K0) + K1 @ _rho @ dag(K1) + K2 @ _rho @ dag(K2) + K3 @ _rho @ dag(K3)


def nice_repr(parameter):
    """Nice parameter representation
        SymPy symbol - as is
        float number - 3 digits after comma
    """
    if isinstance(parameter, float):
        return f'{parameter:.3f}'
    else:
        return f'{parameter}'


def levels_connectivity_check(l1, l2):
    """Check ion layers connectivity for gates"""
    connected_layers_list = [{0, i} for i in range(max(l1, l2) + 1)]
    assert {l1, l2} in connected_layers_list, "Layers are not connected"


def generalized_sigma(index, i, j, dimension=4):
    """Generalized sigma matrix for qudit gates implementation"""

    sigma = np.zeros((dimension, dimension), dtype='complex')

    if index == 0:
        # identity matrix elements
        sigma[i][i] = 1
        sigma[j][j] = 1
    elif index == 1:
        # sigma_x matrix elements
        sigma[i][j] = 1
        sigma[j][i] = 1
    elif index == 2:
        # sigma_y matrix elements
        sigma[i][j] = -1j
        sigma[j][i] = 1j
    elif index == 3:
        # sigma_z matrix elements
        sigma[i][i] = 1
        sigma[j][j] = -1

    return sigma


class QuditGate(cirq.Gate):
    """Base class for qudits gates"""

    def __init__(self, dimension=4, num_qubits=1):
        self.d = dimension
        self.n = num_qubits
        self.symbol = None

    def _num_qubits_(self):
        return self.n

    def _qid_shape_(self):
        return (self.d,) * self.n

    def _circuit_diagram_info_(self, args):
        return (self.symbol,) * self.n


class QuditRGate(QuditGate):
    """Rotation between two specified qudit levels: l1 and l2"""

    def __init__(self, l1, l2, theta, phi, dimension=4):
        super().__init__(dimension=dimension)
        levels_connectivity_check(l1, l2)
        self.l1 = l1
        self.l2 = l2
        self.theta = theta
        self.phi = phi

    def _unitary_(self):
        sigma_x = generalized_sigma(1, self.l1, self.l2, dimension=self.d)
        sigma_y = generalized_sigma(2, self.l1, self.l2, dimension=self.d)

        s = np.sin(self.phi)
        c = np.cos(self.phi)

        u = scipy.linalg.expm(-1j * self.theta / 2 * (c * sigma_x + s * sigma_y))

        return u

    def _is_parameterized_(self) -> bool:
        return cirq.protocols.is_parameterized(any((self.theta, self.phi)))

    def _resolve_parameters_(self, resolver: 'cirq.ParamResolver', recursive: bool):
        return self.__class__(self.l1, self.l2, resolver.value_of(self.theta, recursive),
                              resolver.value_of(self.phi, recursive), dimension=self.d)

    def _circuit_diagram_info_(self, args):
        self.symbol = 'R'
        SUB = str.maketrans("0123456789", "₀₁₂₃₄₅₆₇₈₉")
        SUP = str.maketrans("0123456789", "⁰¹²³⁴⁵⁶⁷⁸⁹")
        return f'{self.symbol}{str(self.l1).translate(SUB)}{str(self.l2).translate(SUP)}' + f'({nice_repr(self.theta)}, {nice_repr(self.phi)})'


class QuditXXGate(QuditGate):
    """Two qudit rotation for two specified qudit levels: l1 and l2"""

    def __init__(self, l1, l2, theta, dimension=4):
        levels_connectivity_check(l1, l2)
        super().__init__(dimension=dimension, num_qubits=2)
        self.l1 = l1
        self.l2 = l2
        self.theta = theta

    def _unitary_(self):
        sigma_x = generalized_sigma(1, self.l1, self.l2, dimension=self.d)
        u = scipy.linalg.expm(-1j * self.theta / 2 * np.kron(sigma_x, sigma_x))

        return u

    def _is_parameterized_(self) -> bool:
        return cirq.protocols.is_parameterized(self.theta)

    def _resolve_parameters_(self, resolver: 'cirq.ParamResolver', recursive: bool):
        return self.__class__(self.l1, self.l2, resolver.value_of(self.theta, recursive), dimension=self.d)

    def _circuit_diagram_info_(self, args):
        self.symbol = 'XX'
        SUB = str.maketrans("0123456789", "₀₁₂₃₄₅₆₇₈₉")
        SUP = str.maketrans("0123456789", "⁰¹²³⁴⁵⁶⁷⁸⁹")
        info = f'{self.symbol}{str(self.l1).translate(SUB)}{str(self.l2).translate(SUP)}'.translate(
            SUB) + f'({nice_repr(self.theta)})'
        return info, info


class QuditZZGate(QuditGate):
    """Two qudit rotation for two specified qudit levels: l1 and l2"""

    def __init__(self, l1, l2, theta, dimension=4):
        levels_connectivity_check(l1, l2)
        super().__init__(dimension=dimension, num_qubits=2)
        self.l1 = l1
        self.l2 = l2
        self.theta = theta

    def _unitary_(self):
        sigma_z = generalized_sigma(3, self.l1, self.l2, dimension=self.d)
        u = scipy.linalg.expm(-1j * self.theta / 2 * np.kron(sigma_z, sigma_z))

        return u

    def _is_parameterized_(self) -> bool:
        return cirq.protocols.is_parameterized(self.theta)

    def _resolve_parameters_(self, resolver: 'cirq.ParamResolver', recursive: bool):
        return self.__class__(self.l1, self.l2, resolver.value_of(self.theta, recursive), dimension=self.d)

    def _circuit_diagram_info_(self, args):
        self.symbol = 'ZZ'
        SUB = str.maketrans("0123456789", "₀₁₂₃₄₅₆₇₈₉")
        SUP = str.maketrans("0123456789", "⁰¹²³⁴⁵⁶⁷⁸⁹")
        info = f'{self.symbol}{str(self.l1).translate(SUB)}{str(self.l2).translate(SUP)}'.translate(
            SUB) + f'({nice_repr(self.theta)})'
        return info, info


class QuditBarrier(QuditGate):
    """Just barrier for visual separation in circuit diagrams. Does nothing"""

    def __init__(self, dimension=4, num_qudits=2):
        super().__init__(dimension=dimension, num_qubits=num_qudits)
        self.symbol = '|'

    def _unitary_(self):
        return np.eye(self.d * self.d)


class QuditArbitraryUnitary(QuditGate):
    """Random unitary acts on qubits"""

    def __init__(self, dimension=4, num_qudits=2):
        super().__init__(dimension=dimension, num_qubits=num_qudits)
        self.unitary = np.array(scipy.stats.unitary_group.rvs(self.d ** self.n))
        self.symbol = 'U'

    def _unitary_(self):
        return self.unitary


'''
if __name__ == '__main__':
    n = 3  # number of qudits
    d = 4  # dimension of qudits

    qudits = cirq.LineQid.range(n, dimension=d)

    alpha = sympy.Symbol('alpha')
    beta = sympy.Symbol('beta')

    print('Qudit R Gate')
    circuit = cirq.Circuit(QuditRGate(0, 1, alpha, beta, dimension=d).on(qudits[0]))
    param_resolver = cirq.ParamResolver({'alpha': 0.2, 'beta': 0.3})
    resolved_circuit = cirq.resolve_parameters(circuit, param_resolver)
    print(resolved_circuit)
    print()

    print('Qudit XX Gate')
    circuit = cirq.Circuit(QuditXXGate(0, 2, beta, dimension=d).on(*qudits[:2]))
    param_resolver = cirq.ParamResolver({'alpha': 0.2, 'beta': 0.3})
    resolved_circuit = cirq.resolve_parameters(circuit, param_resolver)
    print(resolved_circuit)
    print()

    print('Qudit Barrier')
    circuit = cirq.Circuit(QuditBarrier(num_qudits=n, dimension=d).on(*qudits))
    print(circuit)
    print()

    print('Qudit Arbitrary Unitary Gate')
    circuit = cirq.Circuit(QuditArbitraryUnitary(num_qudits=n, dimension=d).on(*qudits))
    print(circuit)
'''
'''
#фазовый
class QutritDepolarizingChannel(QuditGate):

    def __init__(self,PP, p_matrix=None):
        super().__init__(dimension=3, num_qubits=1)

        # Calculation of the parameter p based on average experimental error of single qudit gate
        f1 = 0.9
        self.p1 = (1 - f1) / (1 - 1 / self.d ** 2)
        self.p1 = PP
        #print(self.d)
        #print((1 / self.d ** 2))

        # Choi matrix initialization


        if p_matrix is None:
            self.p_matrix = self.p1 / (self.d ** 2) * np.ones((self.d, self.d))
        else:
            self.p_matrix = p_matrix
        self.p_matrix[0, 0] += (1 - self.p1)  # identity probability
        self.p_matrix = np.array([[1/2, 0], [0, 1/2]])
        #print('prob[0,0]', self.p_matrix[0, 0])
        #print('prob_sum', self.p_matrix.sum())

        #print('prob_sum', self.p_matrix.sum())

    def _mixture_(self):
        ps = []
        for i in range(self.d):
            for j in range(self.d):
                pinv = np.linalg.inv(self.p_matrix)
                op = E(basis, i, j, self.p1, paulies1)
                #print(np.trace(op))
                ps.append(op)
        #print('total_sum', (np.trace(np.array(ps)) * self.p_matrix).sum())
        #chm = np.kron(np.ones(3), ps)
        X = np.array([[0, 1, 0], [1, 0, 0], [0, 0, 1]])
        Y = np.array([[0, complex(0, -1), 0], [complex(0, 1), 0, 0], [0, 0, 1]])
        Z = np.array([[1, 0, 0], [0, -1, 0], [0, 0, 1]])
        m1 = 3**0.5*np.array([[1,0,0],[0,(1 - self.p1)**0.5, 0], [0,0,(1 - self.p1)**0.5]])
        m2 = 3**0.5*np.array([[0,(self.p1)**0.5,0],[0,0, 0], [0,0,0]])
        m3 = 3**0.5*np.array([[0,0,0],[0,0,(self.p1)**0.5], [0,0,0]])
        m4 = 2**0.5 * (1-self.p1)**0.5 * np.eye(3)
        omega = np.exp(complex(0, 2 * np.pi / 3))
        m5 =2**0.5 *  (self.p1)**0.5*np.array([[1,0,0],[0,omega,0], [0,0,omega**2]])
        id = np.eye(3) - np.eye(3)
        shiz_massiv = [m4, id, id, m5]
        return tuple(zip(self.p_matrix.flatten(), shiz_massiv))

    def _circuit_diagram_info_(self, args):
        return f"Φ(p1={self.p1:.3f})"

'''


# деполяризующий
class QutritDepolarizingChannel(QuditGate):

    def __init__(self, PP, p_matrix=None):
        super().__init__(dimension=3, num_qubits=1)

        # Calculation of the parameter p based on average experimental error of single qudit gate
        f1 = 0.9
        self.p1 = (1 - f1) / (1 - 1 / self.d ** 2)
        self.p1 = PP
        # print(self.d)
        # print((1 / self.d ** 2))

        # Choi matrix initialization

        if p_matrix is None:
            self.p_matrix = (1 - self.p1) / (self.d ** 2) * np.ones((self.d, self.d))
            self.p_matrix = np.zeros_like(self.p_matrix)
            # self.p_matrix = np.ones((self.d, self.d))
        else:
            self.p_matrix = p_matrix
        # self.p_matrix[0, 0] += (1 - self.p1)  # identity probability
        for o in range(3):
            for oo in range(3):
                # self.p_matrix[o, oo] = 1 / np.trace(E(basis, o, oo, self.p1, paulies1))
                self.p_matrix[o, oo] = 1 / 9
        # self.p_matrix[0, 0] += 1

        if p_matrix is None:
            self.p_matrix = self.p1 / (self.d ** 2) * np.ones((self.d, self.d))
        else:
            self.p_matrix = p_matrix
        self.p_matrix[0, 0] += (1 - self.p1)  # identity probability
        self.p_matrix = np.array([[(1 - self.p1), self.p1 / 3], [self.p1 / 3, self.p1 / 3]])
        # print('prob[0,0]', self.p_matrix[0, 0])
        # print('prob_sum', self.p_matrix.sum())

        # print('prob_sum', self.p_matrix.sum())

    def _mixture_(self):
        ps = []
        for i in range(self.d):
            for j in range(self.d):
                pinv = np.linalg.inv(self.p_matrix)
                op = E(basis, i, j, self.p1, paulies1)
                # print(np.trace(op))
                ps.append(op)
        # print('total_sum', (np.trace(np.array(ps)) * self.p_matrix).sum())
        # chm = np.kron(np.ones(3), ps)
        X = np.array([[0, 1, 0], [1, 0, 0], [0, 0, 1]])
        Y = np.array([[0, complex(0, -1), 0], [complex(0, 1), 0, 0], [0, 0, 1]])
        Z = np.array([[1, 0, 0], [0, -1, 0], [0, 0, 1]])
        id = np.eye(3)
        shiz_massiv = [id, X, Y, Z]
        return tuple(zip(self.p_matrix.flatten(), shiz_massiv))

    def _circuit_diagram_info_(self, args):
        return f"Φ(p1={self.p1:.3f})"


'''
#АМПЛИТУДНЫЙ
class QutritDepolarizingChannel(QuditGate):

    def __init__(self,PP, p_matrix=None):
        super().__init__(dimension=3, num_qubits=1)

        # Calculation of the parameter p based on average experimental error of single qudit gate
        f1 = 0.9
        self.p1 = (1 - f1) / (1 - 1 / self.d ** 2)
        self.p1 = PP
        #print(self.d)
        #print((1 / self.d ** 2))

        # Choi matrix initialization


        if p_matrix is None:
            self.p_matrix = self.p1 / (self.d ** 2) * np.ones((self.d, self.d))
        else:
            self.p_matrix = p_matrix
        self.p_matrix[0, 0] += (1 - self.p1)  # identity probability
        self.p_matrix = np.array([[1/3, 1 / 3], [1 / 3, 0]])
        #print('prob[0,0]', self.p_matrix[0, 0])
        #print('prob_sum', self.p_matrix.sum())

        #print('prob_sum', self.p_matrix.sum())

    def _mixture_(self):
        ps = []
        for i in range(self.d):
            for j in range(self.d):
                pinv = np.linalg.inv(self.p_matrix)
                op = E(basis, i, j, self.p1, paulies1)
                #print(np.trace(op))
                ps.append(op)
        #print('total_sum', (np.trace(np.array(ps)) * self.p_matrix).sum())
        #chm = np.kron(np.ones(3), ps)
        X = np.array([[0, 1, 0], [1, 0, 0], [0, 0, 1]])
        Y = np.array([[0, complex(0, -1), 0], [complex(0, 1), 0, 0], [0, 0, 1]])
        Z = np.array([[1, 0, 0], [0, -1, 0], [0, 0, 1]])
        m1 = 3**0.5*np.array([[1,0,0],[0,(1 - self.p1)**0.5, 0], [0,0,(1 - self.p1)**0.5]])
        m2 = 3**0.5*np.array([[0,(self.p1)**0.5,0],[0,0, 0], [0,0,0]])
        m3 = 3**0.5*np.array([[0,0,0],[0,0,(self.p1)**0.5], [0,0,0]])
        id = np.eye(3) - np.eye(3)
        shiz_massiv = [m1, m2, m3, id]
        return tuple(zip(self.p_matrix.flatten(), shiz_massiv))

    def _circuit_diagram_info_(self, args):
        return f"Φ(p1={self.p1:.3f})"

    def _circuit_diagram_info_(self, args):
        return f"Φ(p1={self.p1:.3f})"
'''


class QutritAmplitudeChannel(QuditGate):

    def __init__(self, PP, p_matrix=None):
        super().__init__(dimension=3, num_qubits=1)

        # Calculation of the parameter p based on average experimental error of single qudit gate
        f1 = 0.9
        self.p1 = (1 - f1) / (1 - 1 / self.d ** 2)
        self.p1 = PP
        # print(self.d)
        # print((1 / self.d ** 2))

        # Choi matrix initialization
        '''
        if p_matrix is None:
            self.p_matrix = (1 - self.p1) / (self.d ** 2) * np.ones((self.d, self.d))
            self.p_matrix = np.zeros_like(self.p_matrix)
            #self.p_matrix = np.ones((self.d, self.d))
        else:
            self.p_matrix = p_matrix
        #self.p_matrix[0, 0] += (1 - self.p1)  # identity probability
        for o in range(3):
            for oo in range(3):
                #self.p_matrix[o, oo] = 1 / np.trace(E(basis, o, oo, self.p1, paulies1))
                self.p_matrix[o, oo] = 1 / 9
        #self.p_matrix[0, 0] += 1
        '''

        if p_matrix is None:
            self.p_matrix = self.p1 / (self.d ** 2) * np.ones((self.d, self.d))
        else:
            self.p_matrix = p_matrix
        self.p_matrix[0, 0] += (1 - self.p1)  # identity probability
        self.p_matrix = np.array([[(1 - self.p1), self.p1 / 3], [self.p1 / 3, self.p1 / 3]])
        # print('prob[0,0]', self.p_matrix[0, 0])
        # print('prob_sum', self.p_matrix.sum())

        # print('prob_sum', self.p_matrix.sum())

    def _mixture_(self):
        ps = []
        for i in range(self.d):
            for j in range(self.d):
                pinv = np.linalg.inv(self.p_matrix)
                op = E(basis, i, j, self.p1, paulies1)
                # print(np.trace(op))
                ps.append(op)
        # print('total_sum', (np.trace(np.array(ps)) * self.p_matrix).sum())
        # chm = np.kron(np.ones(3), ps)
        X = np.array([[0, 1, 0], [1, 0, 0], [0, 0, 1]])
        Y = np.array([[0, complex(0, -1), 0], [complex(0, 1), 0, 0], [0, 0, 1]])
        Z = np.array([[1, 0, 0], [0, -1, 0], [0, 0, 1]])
        Ea1 = np.array([[1, 0, 0], [0, (1 - self.p1) ** 0.5, 0], [0, 0, (1 - self.p1) ** 0.5]])
        Ea2 = np.array([[0, self.p1 ** 0.5, 0], [0, 0, 0], [0, 0, 0]])
        Ea3 = np.array([[0, 0, self.p1 ** 0.5], [0, 0, 0], [0, 0, 0]])
        id = np.eye(3)
        shiz_massiv = [Ea1, Ea2, Ea3]
        return tuple(zip(self.p_matrix.flatten(), shiz_massiv))

    def _circuit_diagram_info_(self, args):
        return f"Φ(p1={self.p1:.3f})"

def R(fi, hi, i=0, j=1):
    N = 3
    if i == j:
        return np.eye(N)
    if i > j:
        i, j = j, i
    x_for_ms = np.zeros((N, N))
    x_for_ms[i][j] = 1
    x_for_ms[j][i] = 1
    y_for_ms = np.zeros((N, N))
    y_for_ms[i][j] = -1
    y_for_ms[j][i] = 1
    y_for_ms = y_for_ms * 1j

    m = np.cos(fi) * x_for_ms + np.sin(fi) * y_for_ms

    return linalg.expm(-1j * m * hi / 2)



'''
def R(fi, hi, i=0, j=1):
    I = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
    x01_for_ms = np.array([[0, 1, 0],
                           [1, 0, 0],
                           [0, 0, 0]])
    y01_for_ms = np.array([[0, complex(0, -1), 0],
                           [complex(0, 1), 0, 0],
                           [0, 0, 0]])
    x12_for_ms = np.array([[0, 0, 0],
                           [0, 0, 1],
                           [0, 1, 0]])
    y12_for_ms = np.array([[0, 0, 0],
                           [0, 0, complex(0, -1)],
                           [0, complex(0, 1), 0]])
    x02_for_ms = np.array([[0, 0, 1],
                           [0, 0, 0],
                           [1, 0, 0]])
    y02_for_ms = np.array([[0, 0, complex(0, -1)],
                           [0, 0, 0],
                           [complex(0, 1), 0, 0]])
    if (i, j) == (0, 1):
        x_for_ms = x01_for_ms
        y_for_ms = y01_for_ms
    elif (i, j) == (1, 2):
        x_for_ms = x12_for_ms
        y_for_ms = y12_for_ms
    else:
        x_for_ms = x02_for_ms
        y_for_ms = y02_for_ms
    m = np.cos(fi) * x_for_ms + np.sin(fi) * y_for_ms

    return linalg.expm(complex(0, -1) * m * hi / 2)
'''

def make_ms_matrix(N, fi, hi, i, j, k, l):
    if i == j:
        return np.eye(N)
    if i > j:
        i, j = j, i
    x_for_ms1 = np.zeros((N, N))
    x_for_ms1[i][j] = 1
    x_for_ms1[j][i] = 1
    y_for_ms1 = np.zeros((N, N))
    y_for_ms1[i][j] = -1
    y_for_ms1[j][i] = 1
    y_for_ms1 = 1j * y_for_ms1
    if k == l:
        return
    if k > l:
        k, l = l, k
    x_for_ms2 = np.zeros((N, N))
    x_for_ms2[k][l] = 1
    x_for_ms2[l][k] = 1
    y_for_ms2 = np.zeros((N, N))
    y_for_ms2[k][l] = -1
    y_for_ms2[l][k] = 1
    y_for_ms1 = 1j * y_for_ms1

    m = np.kron((np.cos(fi) * x_for_ms1 + np.sin(fi) * y_for_ms1), (np.cos(fi) * x_for_ms2 + np.sin(fi) * y_for_ms2))
    m = -1j * m * hi
    return linalg.expm(m)



class TwoQuditMSGate3_c(gate_features.TwoQubitGate
                        ):

    def _json_dict_(self):
        return {
            'cirq_type': self.__class__.__name__
        }

    @classmethod
    def _from_json_dict_(cls, **kwargs):
        return cls()

    def _qid_shape_(self):
        return (3, 3,)

    def _unitary_(self):
        matrix = make_ms_matrix(0, -np.pi / 2)
        return matrix

    def num_controls(self):
        return 2

    def _circuit_diagram_info_(self, args: 'cirq.CircuitDiagramInfoArgs'
                               ) -> 'cirq.CircuitDiagramInfo':
        return protocols.CircuitDiagramInfo(
            wire_symbols=('XX0101_c',
                          'XX0101_c'))


class TwoQuditMSGate02(gate_features.TwoQubitGate
                      ):

    def _json_dict_(self):
        return {
            'cirq_type': self.__class__.__name__
        }

    @classmethod
    def _from_json_dict_(cls, **kwargs):
        return cls()

    def _qid_shape_(self):
        return (3, 3,)

    def _unitary_(self):
        matrix = make_ms_matrix(3, 0, np.pi / 2,0,1,0,2)
        return matrix

    def num_controls(self):
        return 2

    def _circuit_diagram_info_(self, args: 'cirq.CircuitDiagramInfoArgs'
                               ) -> 'cirq.CircuitDiagramInfo':
        return protocols.CircuitDiagramInfo(
            wire_symbols=('XX0101',
                          'XX0101'))

class TwoQuditMSGate01(gate_features.TwoQubitGate
                      ):

    def _json_dict_(self):
        return {
            'cirq_type': self.__class__.__name__
        }

    @classmethod
    def _from_json_dict_(cls, **kwargs):
        return cls()

    def _qid_shape_(self):
        return (3, 3,)

    def _unitary_(self):
        matrix = make_ms_matrix(3, 0, np.pi / 2,0,1,0,1)
        return matrix

    def num_controls(self):
        return 2

    def _circuit_diagram_info_(self, args: 'cirq.CircuitDiagramInfoArgs'
                               ) -> 'cirq.CircuitDiagramInfo':
        return protocols.CircuitDiagramInfo(
            wire_symbols=('XX0101',
                          'XX0101'))

class unit3(gate_features.ThreeQubitGate
                      ):

    def _json_dict_(self):
        return {
            'cirq_type': self.__class__.__name__
        }

    @classmethod
    def _from_json_dict_(cls, **kwargs):
        return cls()

    def _qid_shape_(self):
        return (3, 3, 3)

    def _unitary_(self):
        matrix = unit
        return matrix

    def num_controls(self):
        return 3

    def _circuit_diagram_info_(self, args: 'cirq.CircuitDiagramInfoArgs'
                               ) -> 'cirq.CircuitDiagramInfo':
        return protocols.CircuitDiagramInfo(
            wire_symbols=('XX0101',
                          'XX0101'))


class TwoQuditMSGate12(gate_features.TwoQubitGate
                      ):

    def _json_dict_(self):
        return {
            'cirq_type': self.__class__.__name__
        }

    @classmethod
    def _from_json_dict_(cls, **kwargs):
        return cls()

    def _qid_shape_(self):
        return (3, 3,)

    def _unitary_(self):
        matrix = make_ms_matrix(3, 0, np.pi / 2, 0,1,1,2)
        return matrix

    def num_controls(self):
        return 2

    def _circuit_diagram_info_(self, args: 'cirq.CircuitDiagramInfoArgs'
                               ) -> 'cirq.CircuitDiagramInfo':
        return protocols.CircuitDiagramInfo(
            wire_symbols=('XX0101',
                          'XX0101'))

class TwoQuditMSGate01_c(gate_features.TwoQubitGate
                      ):

    def _json_dict_(self):
        return {
            'cirq_type': self.__class__.__name__
        }

    @classmethod
    def _from_json_dict_(cls, **kwargs):
        return cls()

    def _qid_shape_(self):
        return (3, 3,)

    def _unitary_(self):
        matrix = make_ms_matrix(3, 0, -np.pi / 2,0,1,0,1)
        return matrix

    def num_controls(self):
        return 2

    def _circuit_diagram_info_(self, args: 'cirq.CircuitDiagramInfoArgs'
                               ) -> 'cirq.CircuitDiagramInfo':
        return protocols.CircuitDiagramInfo(
            wire_symbols=('XX0101',
                          'XX0101'))

class rTwoQuditMSGate01(gate_features.TwoQubitGate
                      ):

    def _json_dict_(self):
        return {
            'cirq_type': self.__class__.__name__
        }

    @classmethod
    def _from_json_dict_(cls, **kwargs):
        return cls()

    def _qid_shape_(self):
        return (3, 3,)

    def _unitary_(self):
        matrix = make_ms_matrix(3, 0, -np.pi / 2,0,1,0,1)
        return matrix

    def num_controls(self):
        return 2

    def _circuit_diagram_info_(self, args: 'cirq.CircuitDiagramInfoArgs'
                               ) -> 'cirq.CircuitDiagramInfo':
        return protocols.CircuitDiagramInfo(
            wire_symbols=('XX0101',
                          'XX0101'))

class rTwoQuditMSGate02(gate_features.TwoQubitGate
                      ):

    def _json_dict_(self):
        return {
            'cirq_type': self.__class__.__name__
        }

    @classmethod
    def _from_json_dict_(cls, **kwargs):
        return cls()

    def _qid_shape_(self):
        return (3, 3,)

    def _unitary_(self):
        matrix = make_ms_matrix(3, 0, -np.pi / 2,0,1,0,2)
        return matrix

    def num_controls(self):
        return 2

    def _circuit_diagram_info_(self, args: 'cirq.CircuitDiagramInfoArgs'
                               ) -> 'cirq.CircuitDiagramInfo':
        return protocols.CircuitDiagramInfo(
            wire_symbols=('XX0101',
                          'XX0101'))

class rTwoQuditMSGate12(gate_features.TwoQubitGate
                      ):

    def _json_dict_(self):
        return {
            'cirq_type': self.__class__.__name__
        }

    @classmethod
    def _from_json_dict_(cls, **kwargs):
        return cls()

    def _qid_shape_(self):
        return (3, 3,)

    def _unitary_(self):
        matrix = make_ms_matrix(3, 0, -np.pi / 2,0,1,1,2)
        return matrix

    def num_controls(self):
        return 2

    def _circuit_diagram_info_(self, args: 'cirq.CircuitDiagramInfoArgs'
                               ) -> 'cirq.CircuitDiagramInfo':
        return protocols.CircuitDiagramInfo(
            wire_symbols=('XX0101',
                          'XX0101'))

class U_press(gate_features.TwoQubitGate
              ):

    def _json_dict_(self):
        return {
            'cirq_type': self.__class__.__name__
        }

    @classmethod
    def _from_json_dict_(cls, **kwargs):
        return cls()

    def _qid_shape_(self):
        return (3, 3, 3,)

    def _unitary_(self):
        matrix = make_ms_matrix(0, np.pi / 2)
        return matrix

    def num_controls(self):
        return 2

    def _circuit_diagram_info_(self, args: 'cirq.CircuitDiagramInfoArgs'
                               ) -> 'cirq.CircuitDiagramInfo':
        return protocols.CircuitDiagramInfo(
            wire_symbols=('XX0101',
                          'XX0101'))


class U(cirq.Gate):
    def __init__(self, mat, diag_i='R'):
        self.mat = mat
        self.diag_info = diag_i

    def _qid_shape_(self):
        return (3,)

    def _unitary_(self):
        return self.mat

    def _circuit_diagram_info_(self, args):
        return self.diag_info




def U1_clear(cirquit, q1, q2):
    u1 = U(R(0, -np.pi, 1, 2), 'Rx(-π)12')
    u2 = U(R(np.pi / 2, np.pi / 2, 0, 1), 'Ry(π/2)01')
    u6 = U(R(np.pi / 2, -np.pi, 0, 2), 'Ry(-π)02')
    cirquit.append([u1(q1), u6(q2)], strategy=InsertStrategy.INLINE)
    # adde(cirquit, [u1, u6], [q1, q2], 1)
    cirquit.append([u2(q1)], strategy=InsertStrategy.INLINE)
    # adde(cirquit, [u2], [q1], 1)
    xx = TwoQuditMSGate01()
    cirquit.append([xx(q1, q2)], strategy=InsertStrategy.INLINE)
    # error(cirquit, [q1, q2], PMS)
    # adde(cirquit, [xx], [q1, q2], 2)

def rU1_clear(cirquit, q1, q2):
    u1 = U(R(0, np.pi, 1, 2), 'Rx(-π)12')
    u2 = U(R(np.pi / 2, -np.pi / 2, 0, 1), 'Ry(π/2)01')
    u6 = U(R(np.pi / 2, np.pi, 0, 2), 'Ry(-π)02')
    xx = rTwoQuditMSGate01()
    cirquit.append([xx(q1, q2)], strategy=InsertStrategy.INLINE)
    cirquit.append([u2(q1)], strategy=InsertStrategy.INLINE)
    cirquit.append([u1(q1), u6(q2)], strategy=InsertStrategy.INLINE)







def U1_c_clear(cirquit, q1, q2):

    u1 = U(R(0, np.pi, 1, 2), 'Rx(π)12')
    u2 = U(R(np.pi / 2, -np.pi / 2, 0, 1), 'Ry(-π/2)01')
    u6 = U(R(np.pi / 2, np.pi, 0, 2), 'Ry(π)02')
    xx_c = TwoQuditMSGate01_c()
    cirquit.append([xx_c(q1, q2)], strategy=InsertStrategy.INLINE)
    # adde(cirquit, [xx_c], [q1, q2], 2)
    # error(cirquit, [q1, q2], PMS)
    # adde(cirquit, [u2], [q1], 1)
    cirquit.append([u2(q1)], strategy=InsertStrategy.INLINE)
    # adde(cirquit, [u1, u6], [q1, q2], 1)
    cirquit.append([u1(q1), u6(q2)], strategy=InsertStrategy.INLINE)


def CX_clear01(cirquit, q1, q2):
    u1 = U(R(0, -np.pi, 1, 2), 'Rx(-π)12')
    u2 = U(R(np.pi / 2, np.pi / 2, 0, 1), 'Ry(π/2)01')
    u3 = U(R(0, -np.pi, 0, 1), 'Rx(-π)01')
    u4 = U(R(np.pi / 2, -np.pi / 2, 0, 1), 'Ry(-π/2)01')
    u5 = U(R(0, np.pi, 1, 2), 'Rx(π)12')
    # adde(cirquit, [u1], [q1], 1)
    # adde(cirquit, [u2], [q1], 1)
    cirquit.append([u1(q1)], strategy=InsertStrategy.INLINE)
    cirquit.append([u2(q1)], strategy=InsertStrategy.INLINE)
    xx = TwoQuditMSGate01()
    # adde(cirquit, [xx], [q1, q2], 2)
    cirquit.append([xx(q1, q2)], strategy=InsertStrategy.INLINE)
    # error(cirquit, [q1, q2], 2)
    # adde(cirquit, [u3, u3], [q1, q2], 1)
    # adde(cirquit, [u4], [q1], 1)
    # adde(cirquit, [u5], [q1], 1)
    cirquit.append([u3(q1), u3(q2)], strategy=InsertStrategy.INLINE)
    cirquit.append([u4(q1)], strategy=InsertStrategy.INLINE)
    cirquit.append([u5(q1)], strategy=InsertStrategy.INLINE)

def CX_clear02(cirquit, q1, q2):
    u1 = U(R(0, -np.pi, 1, 2), 'Rx(-π)12')
    u2 = U(R(np.pi / 2, np.pi / 2, 0, 1), 'Ry(π/2)01')
    u3 = U(R(0, -np.pi, 0, 1), 'Rx(-π)01')
    u35 = U(R(0, -np.pi, 0, 2), 'Rx(-π)01')
    u4 = U(R(np.pi / 2, -np.pi / 2, 0, 1), 'Ry(-π/2)01')
    u5 = U(R(0, np.pi, 1, 2), 'Rx(π)12')
    # adde(cirquit, [u1], [q1], 1)
    # adde(cirquit, [u2], [q1], 1)
    cirquit.append([u1(q1)], strategy=InsertStrategy.INLINE)
    cirquit.append([u2(q1)], strategy=InsertStrategy.INLINE)
    xx = TwoQuditMSGate02()
    # adde(cirquit, [xx], [q1, q2], 2)
    cirquit.append([xx(q1, q2)], strategy=InsertStrategy.INLINE)
    # error(cirquit, [q1, q2], 2)
    # adde(cirquit, [u3, u3], [q1, q2], 1)
    # adde(cirquit, [u4], [q1], 1)
    # adde(cirquit, [u5], [q1], 1)
    cirquit.append([u3(q1)], strategy=InsertStrategy.INLINE)
    cirquit.append([u35(q2)], strategy=InsertStrategy.INLINE)
    cirquit.append([u4(q1)], strategy=InsertStrategy.INLINE)
    cirquit.append([u5(q1)], strategy=InsertStrategy.INLINE)


def CX_clear12(cirquit, q1, q2):
    u1 = U(R(0, -np.pi, 1, 2), 'Rx(-π)12')
    u2 = U(R(np.pi / 2, np.pi / 2, 0, 1), 'Ry(π/2)01')
    u3 = U(R(0, -np.pi, 0, 1), 'Rx(-π)01')
    u35 = U(R(0, -np.pi, 1, 2), 'Rx(-π)01')
    u4 = U(R(np.pi / 2, -np.pi / 2, 0, 1), 'Ry(-π/2)01')
    u5 = U(R(0, np.pi, 1, 2), 'Rx(π)12')
    # adde(cirquit, [u1], [q1], 1)
    # adde(cirquit, [u2], [q1], 1)
    cirquit.append([u1(q1)], strategy=InsertStrategy.INLINE)
    cirquit.append([u2(q1)], strategy=InsertStrategy.INLINE)
    xx = TwoQuditMSGate12()
    # adde(cirquit, [xx], [q1, q2], 2)
    cirquit.append([xx(q1, q2)], strategy=InsertStrategy.INLINE)
    # error(cirquit, [q1, q2], 2)
    # adde(cirquit, [u3, u3], [q1, q2], 1)
    # adde(cirquit, [u4], [q1], 1)
    # adde(cirquit, [u5], [q1], 1)
    cirquit.append([u3(q1)], strategy=InsertStrategy.INLINE)
    cirquit.append([u35(q2)], strategy=InsertStrategy.INLINE)
    cirquit.append([u4(q1)], strategy=InsertStrategy.INLINE)
    cirquit.append([u5(q1)], strategy=InsertStrategy.INLINE)


def rCX_clear12(cirquit, q1, q2):
    u1 = U(R(0, np.pi, 1, 2), 'Rx(-π)12')
    u2 = U(R(np.pi / 2, -np.pi / 2, 0, 1), 'Ry(π/2)01')
    u3 = U(R(0, np.pi, 0, 1), 'Rx(-π)01')
    u35 = U(R(0, np.pi, 1, 2), 'Rx(-π)01')
    u4 = U(R(np.pi / 2, np.pi / 2, 0, 1), 'Ry(-π/2)01')
    u5 = U(R(0, -np.pi, 1, 2), 'Rx(π)12')
    xx = rTwoQuditMSGate12()
    cirquit.append([u5(q1)], strategy=InsertStrategy.INLINE)
    cirquit.append([u4(q1)], strategy=InsertStrategy.INLINE)
    cirquit.append([u3(q1)], strategy=InsertStrategy.INLINE)
    cirquit.append([u35(q2)], strategy=InsertStrategy.INLINE)
    cirquit.append([xx(q1, q2)], strategy=InsertStrategy.INLINE)
    cirquit.append([u2(q1)], strategy=InsertStrategy.INLINE)
    cirquit.append([u1(q1)], strategy=InsertStrategy.INLINE)

def rCX_clear01(cirquit, q1, q2):
    u1 = U(R(0, np.pi, 1, 2), 'Rx(-π)12')
    u2 = U(R(np.pi / 2, -np.pi / 2, 0, 1), 'Ry(π/2)01')
    u3 = U(R(0, np.pi, 0, 1), 'Rx(-π)01')
    u35 = U(R(0, np.pi, 0, 1), 'Rx(-π)01')
    u4 = U(R(np.pi / 2, np.pi / 2, 0, 1), 'Ry(-π/2)01')
    u5 = U(R(0, -np.pi, 1, 2), 'Rx(π)12')
    xx = rTwoQuditMSGate01()
    cirquit.append([u5(q1)], strategy=InsertStrategy.INLINE)
    cirquit.append([u4(q1)], strategy=InsertStrategy.INLINE)
    cirquit.append([u3(q1)], strategy=InsertStrategy.INLINE)
    cirquit.append([u35(q2)], strategy=InsertStrategy.INLINE)
    cirquit.append([xx(q1, q2)], strategy=InsertStrategy.INLINE)
    cirquit.append([u2(q1)], strategy=InsertStrategy.INLINE)
    cirquit.append([u1(q1)], strategy=InsertStrategy.INLINE)

def rCX_clear02(cirquit, q1, q2):
    u1 = U(R(0, np.pi, 1, 2), 'Rx(-π)12')
    u2 = U(R(np.pi / 2, -np.pi / 2, 0, 1), 'Ry(π/2)01')
    u3 = U(R(0, np.pi, 0, 1), 'Rx(-π)01')
    u35 = U(R(0, np.pi, 0, 2), 'Rx(-π)01')
    u4 = U(R(np.pi / 2, np.pi / 2, 0, 1), 'Ry(-π/2)01')
    u5 = U(R(0, -np.pi, 1, 2), 'Rx(π)12')
    xx = rTwoQuditMSGate02()
    cirquit.append([u5(q1)], strategy=InsertStrategy.INLINE)
    cirquit.append([u4(q1)], strategy=InsertStrategy.INLINE)
    cirquit.append([u3(q1)], strategy=InsertStrategy.INLINE)
    cirquit.append([u35(q2)], strategy=InsertStrategy.INLINE)
    cirquit.append([xx(q1, q2)], strategy=InsertStrategy.INLINE)
    cirquit.append([u2(q1)], strategy=InsertStrategy.INLINE)
    cirquit.append([u1(q1)], strategy=InsertStrategy.INLINE)








def CCX01(cirquit, q1, q2, q3):
    U1_clear(cirquit, q1, q2)
    CX_clear01(cirquit, q2, q3)
    rU1_clear(cirquit, q1, q2)

def CCX02(cirquit, q1, q2, q3):
    U1_clear(cirquit, q1, q2)
    CX_clear02(cirquit, q2, q3)
    rU1_clear(cirquit, q1, q2)

def CCX12(cirquit, q1, q2, q3):
    rU1_clear(cirquit, q1, q2)
    rCX_clear12(cirquit, q2, q3)
    rU1_clear(cirquit, q1, q2)

def CCX01_r(cirquit, q1, q2, q3):
    rU1_clear(cirquit, q1, q2)
    rCX_clear01(cirquit, q2, q3)
    U1_clear(cirquit, q1, q2)

def CCX02_r(cirquit, q1, q2, q3):
    rU1_clear(cirquit, q1, q2)
    rCX_clear02(cirquit, q2, q3)
    U1_clear(cirquit, q1, q2)

def CCX12_r(cirquit, q1, q2, q3):
    rU1_clear(cirquit, q1, q2)
    rCX_clear12(cirquit, q2, q3)
    U1_clear(cirquit, q1, q2)






class H(cirq.Gate):
    def _qid_shape_(self):
        return (3,)

    def _unitary_(self):
        return R(0, np.pi, 0, 1) @ R(np.pi / 2, np.pi / 2, 0, 1)

    def _circuit_diagram_info_(self, args):
        return 'U_enc'


class X1_conj(cirq.Gate):
    def _qid_shape_(self):
        return (3,)

    def _unitary_(self):
        return np.array([[0, complex(0, -1), 0], [complex(0, -1), 0, 0], [0, 0, 1]])

    def _circuit_diagram_info_(self, args):
        return 'X1_c'


class X2_conj(cirq.Gate):
    def _qid_shape_(self):
        return (3,)

    def _unitary_(self):
        return np.conj(np.array([[0, 0, complex(0, -1)],
                                 [0, 1, 0],
                                 [complex(0, -1), 0, 0]]))

    def _circuit_diagram_info_(self, args):
        return 'X2_c'


class Z1(cirq.Gate):
    def _qid_shape_(self):
        return (3,)

    def _unitary_(self):
        return R(0, np.pi, 0, 1) @ R(np.pi / 2, np.pi, 0, 1)

    def _circuit_diagram_info_(self, args):
        return 'Z1'


class Y1(cirq.Gate):
    def _qid_shape_(self):
        return (3,)

    def _unitary_(self):
        return R(np.pi / 2, np.pi, 0, 1)

    def _circuit_diagram_info_(self, args):
        return 'Y1'


class X12(cirq.Gate):
    def _qid_shape_(self):
        return (3,)

    def _unitary_(self):
        return R(0, np.pi, 1, 2)

    def _circuit_diagram_info_(self, args):
        return 'X2'

class X12r(cirq.Gate):
    def _qid_shape_(self):
        return (3,)

    def _unitary_(self):
        return R(0, -np.pi, 1, 2)

    def _circuit_diagram_info_(self, args):
        return 'X2'

class X02(cirq.Gate):
    def _qid_shape_(self):
        return (3,)

    def _unitary_(self):
        return R(0, np.pi, 0, 2)

    def _circuit_diagram_info_(self, args):
        return 'X2'

class X02r(cirq.Gate):
    def _qid_shape_(self):
        return (3,)

    def _unitary_(self):
        return R(0, -np.pi, 0, 2)

    def _circuit_diagram_info_(self, args):
        return 'X2'


class X1(cirq.Gate):
    def _qid_shape_(self):
        return (3,)

    def _unitary_(self):
        return R(0, np.pi, 0, 1)

    def _circuit_diagram_info_(self, args):
        return 'X1'

class X1r(cirq.Gate):
    def _qid_shape_(self):
        return (3,)

    def _unitary_(self):
        return R(0, -np.pi, 0, 1)

    def _circuit_diagram_info_(self, args):
        return 'X1'



def run_single_qudit(t, N):
    fidelity = 0
    sch = 0
    for alf1 in np.linspace(0, np.pi, N // 2):
        for alf2 in np.linspace(0, 2 * np.pi, N):
            alf2 += 2 * np.pi / N / 2
            # alf1 = random.randint(0, 1000) / 1000 * 2 * np.pi
            # alf2 = random.randint(0, 1000) / 1000 * 2 * np.pi
            sch += 1
            circuit1 = cirq.Circuit()
            qutrits1 = []
            qutrits1.append(cirq.LineQid(0, dimension=3))

            povorot = R(alf1, alf2, 0, 1)
            # !

            pg = U(povorot)
            # circuit1.append([h(qutrits1[0])], strategy=InsertStrategy.INLINE)
            circuit1.append([pg(qutrits1[0])], strategy=InsertStrategy.INLINE)
            # print(cirq.final_density_matrix(circuit1, qubit_order=qutrits1))
            # print()



            povorot_r = R(alf1, -alf2, 0, 1)
            pg_r = U(povorot_r)
            circuit1.append([pg_r(qutrits1[0])], strategy=InsertStrategy.INLINE)
            # circuit1.append([h(qutrits1[0])], strategy=InsertStrategy.INLINE)

            ro_ab = cirq.final_density_matrix(circuit1)

            # print(mat_0)
            fidelity += abs(ro_ab[0][0])
    return fidelity / sch

zZ = np.array([[1,0,0]]).T
eE = np.array([[0,1,0]]).T
fF = np.array([[0,0,1]]).T
A = [zZ, eE, fF]

B = []

def m(a ,b, c, d, e):
    return np.kron(np.kron(np.kron(np.kron(a, b), c), d), e)

for i1 in range(3):
    for i2 in range(3):
        B.append(np.kron(A[i1], A[i2]))

def partial_trace(rho_ab):
    tr = np.eye(3) - np.eye(3)
    for i in range(3):
        for j in range(3):
            for k in range(9):
                tr = tr + np.kron(A[i].T, B[k].T) @ rho_ab @ np.kron(A[j], B[k]) * A[i] @ A[j].T
    return tr


sim = cirq.Simulator()

circuit1 = cirq.Circuit()
qutrits1 = []
qutrits1.append(cirq.LineQid(0, dimension=3))
qutrits1.append(cirq.LineQid(1, dimension=3))
qutrits1.append(cirq.LineQid(2, dimension=3))
qutrits1.append(cirq.LineQid(3, dimension=3))
q1, q2, q3= qutrits1[0], qutrits1[1], qutrits1[2]

q4 = qutrits1[3]
x01 = X1()
x12 = X12()
h = H()


#CX_clear01(circuit1,q1,q2)
UNITARY = unit3()
#circuit1.append([UNITARY(q1,q2,q3)], strategy=InsertStrategy.INLINE)

'''
alf11 = random.randint(0, 1000) / 1000 * 2 * np.pi
alf21 = random.randint(0, 1000) / 1000 * 2 * np.pi
#alf11 = 0
#alf21 = 0
povorot = R(alf11, alf21, 0, 1)
pg = U(povorot)
circuit1.append([pg(qutrits1[0])], strategy=InsertStrategy.INLINE)
alf12 = random.randint(0, 1000) / 1000 * 2 * np.pi
alf22 = random.randint(0, 1000) / 1000 * 2 * np.pi
#alf21 = 0
#alf22 = 0
povorot = R(alf12, alf22, 0, 1)
pg = U(povorot)
circuit1.append([pg(qutrits1[1])], strategy=InsertStrategy.INLINE)
alf13 = random.randint(0, 1000) / 1000 * 2 * np.pi
alf23 = random.randint(0, 1000) / 1000 * 2 * np.pi
#alf13 = 0
#alf23 = 0
povorot = R(alf13, alf23, 0, 1)
pg = U(povorot)
circuit1.append([pg(qutrits1[2])], strategy=InsertStrategy.INLINE)
'''
x01 = X1()
x12 = X12()
x02 = X02()

circuit1.append([x01(qutrits1[2]), x01(qutrits1[0]), x01(qutrits1[1])], strategy=InsertStrategy.INLINE)
#q1, q3 = q3, q1
x01 = X1()
x12 = X12()
x02 = X02()
circuit1.append([x01(q2)], strategy=InsertStrategy.INLINE)
CCX02(circuit1,q2,q3,q1)
circuit1.append([x01(q2)], strategy=InsertStrategy.INLINE)

circuit1.append([x12(q1)], strategy=InsertStrategy.INLINE)
CX_clear01(circuit1,q1,q2)
CX_clear02(circuit1,q1,q2)
CX_clear01(circuit1,q1,q2)
CX_clear02(circuit1,q1,q2)
CX_clear01(circuit1,q1,q3)
CX_clear02(circuit1,q1,q3)
CX_clear01(circuit1,q1,q3)
CX_clear02(circuit1,q1,q3)
circuit1.append([x12(q1)], strategy=InsertStrategy.INLINE)

circuit1.append([x01(q1)], strategy=InsertStrategy.INLINE)
CX_clear01(circuit1,q1,q2)
CX_clear02(circuit1,q1,q2)
circuit1.append([x01(q1)], strategy=InsertStrategy.INLINE)

circuit1.append([x12(q2)], strategy=InsertStrategy.INLINE)
CX_clear01(circuit1,q2,q1)
CX_clear02(circuit1,q2,q1)
circuit1.append([x12(q2)], strategy=InsertStrategy.INLINE)

circuit1.append([x01(q1)], strategy=InsertStrategy.INLINE)
CX_clear01(circuit1,q1,q3)
CX_clear02(circuit1,q1,q3)
CX_clear01(circuit1,q1,q3)
CX_clear02(circuit1,q1,q3)
circuit1.append([x01(q1)], strategy=InsertStrategy.INLINE)

circuit1.append([x12(q3)], strategy=InsertStrategy.INLINE)
CX_clear01(circuit1,q3,q1)
CX_clear02(circuit1,q3,q1)
circuit1.append([x12(q3)], strategy=InsertStrategy.INLINE)

circuit1.append([x01(q4)], strategy=InsertStrategy.INLINE)
#q1, q4 = q4, q1
#circuit1.append([x01(q4)], strategy=InsertStrategy.INLINE)

#x12 = X12r()
#x01 = X1r()
#x02 = X02r()
circuit1.append([x12(q3)], strategy=InsertStrategy.INLINE)
rCX_clear02(circuit1,q3,q1)
rCX_clear01(circuit1,q3,q1)
circuit1.append([x12(q3)], strategy=InsertStrategy.INLINE)

circuit1.append([x01(q1)], strategy=InsertStrategy.INLINE)
rCX_clear02(circuit1,q1,q3)
rCX_clear01(circuit1,q1,q3)
rCX_clear02(circuit1,q1,q3)
rCX_clear01(circuit1,q1,q3)
circuit1.append([x01(q1)], strategy=InsertStrategy.INLINE)

circuit1.append([x12(q2)], strategy=InsertStrategy.INLINE)
rCX_clear02(circuit1,q2,q1)
rCX_clear01(circuit1,q2,q1)
circuit1.append([x12(q2)], strategy=InsertStrategy.INLINE)

circuit1.append([x01(q1)], strategy=InsertStrategy.INLINE)
rCX_clear02(circuit1,q1,q2)
rCX_clear01(circuit1,q1,q2)
circuit1.append([x01(q1)], strategy=InsertStrategy.INLINE)

circuit1.append([x12(q1)], strategy=InsertStrategy.INLINE)
rCX_clear02(circuit1,q1,q3)
rCX_clear01(circuit1,q1,q3)
rCX_clear02(circuit1,q1,q3)
rCX_clear01(circuit1,q1,q3)
rCX_clear02(circuit1,q1,q2)
rCX_clear01(circuit1,q1,q2)
rCX_clear02(circuit1,q1,q2)
rCX_clear01(circuit1,q1,q2)
circuit1.append([x12(q1)], strategy=InsertStrategy.INLINE)

circuit1.append([x01(q2)], strategy=InsertStrategy.INLINE)
CCX02_r(circuit1,q2,q3,q1)
circuit1.append([x01(q2)], strategy=InsertStrategy.INLINE)
'''
povorot = R(alf11, -alf21, 0, 1)
pg = U(povorot)
circuit1.append([pg(qutrits1[0])], strategy=InsertStrategy.INLINE)
#circuit1.append([pg(qutrits1[3])], strategy=InsertStrategy.INLINE)

povorot = R(alf12, -alf22, 0, 1)
pg = U(povorot)
circuit1.append([pg(qutrits1[1])], strategy=InsertStrategy.INLINE)

povorot = R(alf13, -alf23, 0, 1)
pg = U(povorot)
circuit1.append([pg(qutrits1[2])], strategy=InsertStrategy.INLINE)
'''

#circuit1.append([h(qutrits1[2]), h(qutrits1[0]), h(qutrits1[1])], strategy=InsertStrategy.INLINE)


#res1 = sim.simulate(circuit1)
'''
circuit1.append([cirq.measure(qutrits1[0])])
circuit1.append([cirq.measure(qutrits1[1])])
circuit1.append([cirq.measure(qutrits1[2])])
circuit1.append([cirq.measure(qutrits1[3])])'''
res1 = sim.simulate(circuit1)
'''
print(res1.measurements[str(qutrits1[0])][0])
print(res1.measurements[str(qutrits1[1])][0])
print(res1.measurements[str(qutrits1[2])][0])
print(res1.measurements[str(qutrits1[3])][0])'''

#ro_ab = cirq.final_density_matrix(circuit1, qubit_order=qutrits1)
print(res1)



'''
x02 = X02()
circuit1.append([x01(q1)], strategy=InsertStrategy.INLINE)
CX_clear01(circuit1,q1,q3)
CX_clear02(circuit1,q1,q3)
circuit1.append([x01(q1)], strategy=InsertStrategy.INLINE)
res1 = sim.simulate(circuit1)
#ro_ab = cirq.final_density_matrix(circuit1, qubit_order=qutrits1)
print(res1)
'''





'''
povorot = R(alf13, -alf23, 0, 1)
pg = U(povorot)
circuit1.append([pg(qutrits1[2])], strategy=InsertStrategy.INLINE)

povorot = R(alf12, -alf22, 0, 1)
pg = U(povorot)
circuit1.append([pg(qutrits1[1])], strategy=InsertStrategy.INLINE)

povorot = R(alf11, -alf21, 0, 1)
pg = U(povorot)
circuit1.append([pg(qutrits1[0])], strategy=InsertStrategy.INLINE)

circuit1.append([cirq.measure(qutrits1[0])])
circuit1.append([cirq.measure(qutrits1[1])])
circuit1.append([cirq.measure(qutrits1[2])])

res1 = sim.simulate(circuit1)
#ro_ab = cirq.final_density_matrix(circuit1, qubit_order=qutrits1)
#print(res1)
print(res1.measurements[str(qutrits1[0])][0])
print(res1.measurements[str(qutrits1[1])][0])
print(res1.measurements[str(qutrits1[2])][0])
#print(abs(ro_ab))
'''
'''
x01 = X1()
x12 = X12()
#circuit1.append([x01(q3)], strategy=InsertStrategy.INLINE)
#2-19
circuit1.append([x01(q1)], strategy=InsertStrategy.INLINE)
circuit1.append([x01(q2)], strategy=InsertStrategy.INLINE)
CCX01(circuit1,q1,q2,q3)
circuit1.append([x01(q1)], strategy=InsertStrategy.INLINE)
circuit1.append([x01(q3)], strategy=InsertStrategy.INLINE)
CCX12(circuit1,q3,q2,q1)
circuit1.append([x01(q3)], strategy=InsertStrategy.INLINE)
circuit1.append([x01(q1)], strategy=InsertStrategy.INLINE)
CCX01(circuit1,q1,q2,q3)
circuit1.append([x01(q2)], strategy=InsertStrategy.INLINE)
circuit1.append([x01(q1)], strategy=InsertStrategy.INLINE)

res1 = sim.simulate(circuit1)
print(res1)


#5-7
circuit1.append([x01(q1)], strategy=InsertStrategy.INLINE)
CCX01(circuit1,q1,q2,q3)
circuit1.append([x01(q3)], strategy=InsertStrategy.INLINE)
CCX12(circuit1,q1,q3,q2)
circuit1.append([x01(q3)], strategy=InsertStrategy.INLINE)
CCX01(circuit1,q1,q2,q3)
circuit1.append([x01(q1)], strategy=InsertStrategy.INLINE)

#11-13
CCX02(circuit1,q3,q1,q2)
circuit1.append([x12(q2)], strategy=InsertStrategy.INLINE)
CCX01(circuit1,q1,q2,q3)
circuit1.append([x12(q2)], strategy=InsertStrategy.INLINE)
CCX02(circuit1,q3,q1,q2)

#14-22
CCX12(circuit1,q2,q3,q1)
circuit1.append([x12(q1)], strategy=InsertStrategy.INLINE)
CCX01(circuit1,q1,q2,q3)
circuit1.append([x12(q1)], strategy=InsertStrategy.INLINE)
CCX12(circuit1,q2,q3,q1)


#res1 = sim.simulate(circuit1)
#print(res1)
#print(circuit1)
#print(abs(cirq.final_density_matrix(circuit1, qubit_order=qutrits1)))
#print(res1.measurements[str(qutrits1[2])][0])
#print(abs(partial_trace(cirq.final_density_matrix(circuit1, qubit_order=[q3,q2,q1]))))

'''
'''
q3, q4 = q4, q3

CCX01(circuit1,q1,q2,q3)
circuit1.append([x01(q3)], strategy=InsertStrategy.INLINE)
CCX12(circuit1,q3,q1,q2)
circuit1.append([x01(q3)], strategy=InsertStrategy.INLINE)
CCX01(circuit1,q1,q2,q3)

circuit1.append([x01(q2)], strategy=InsertStrategy.INLINE)
circuit1.append([x01(q3)], strategy=InsertStrategy.INLINE)
CCX12(circuit1,q3,q2,q1)
circuit1.append([x01(q3)], strategy=InsertStrategy.INLINE)
CCX01(circuit1,q1,q2,q3)
circuit1.append([x01(q3)], strategy=InsertStrategy.INLINE)
CCX12(circuit1,q3,q2,q1)
circuit1.append([x01(q2)], strategy=InsertStrategy.INLINE)
circuit1.append([x01(q3)], strategy=InsertStrategy.INLINE)

CCX02(circuit1,q3,q2,q1)
circuit1.append([x12(q1)], strategy=InsertStrategy.INLINE)
CCX12(circuit1,q1,q3,q2)
circuit1.append([x12(q1)], strategy=InsertStrategy.INLINE)
CCX02(circuit1,q3,q2,q1)

circuit1.append([x01(q1)], strategy=InsertStrategy.INLINE)
CCX02(circuit1,q1,q3,q2)
circuit1.append([x01(q1)], strategy=InsertStrategy.INLINE)

povorot = R(alf13, -alf23, 0, 1)
pg = U(povorot)
circuit1.append([pg(qutrits1[2])], strategy=InsertStrategy.INLINE)

povorot = R(alf12, -alf22, 0, 1)
pg = U(povorot)
circuit1.append([pg(qutrits1[1])], strategy=InsertStrategy.INLINE)

povorot = R(alf11, -alf21, 0, 1)
pg = U(povorot)
circuit1.append([pg(qutrits1[0])], strategy=InsertStrategy.INLINE)

q3, q4 = q4, q3
circuit1.append([cirq.measure(qutrits1[0])])
circuit1.append([cirq.measure(qutrits1[1])])
circuit1.append([cirq.measure(qutrits1[2])])
circuit1.append([cirq.measure(qutrits1[3])])
res1 = sim.simulate(circuit1)
#print(circuit1)
#print(abs(cirq.final_density_matrix(circuit1, qubit_order=qutrits1)))
print(res1.measurements[str(qutrits1[0])][0])
print(res1.measurements[str(qutrits1[1])][0])
print(res1.measurements[str(qutrits1[2])][0])
print(res1.measurements[str(qutrits1[3])][0])
#print(res1)
'''