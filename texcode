\documentclass[a4paper, 12pt]{article}
\usepackage[a4paper,top=1.5cm, bottom=1.5cm, left=1cm, right=1cm]{geometry}
\usepackage{cmap}
\usepackage{mathtext}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{tabularx}
\usepackage{float}
\usepackage{longtable}
\usepackage{hyperref}
\hypersetup{colorlinks=true,urlcolor=blue}
\usepackage[rgb]{xcolor}
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools}
\usepackage{icomma}
\usepackage{euscript}
\usepackage{mathrsfs}
\usepackage{enumerate}
\usepackage{caption}
\usepackage{enumerate}
\mathtoolsset{showonlyrefs=true}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{braket}
\usepackage{physics}

\usepackage{tcolorbox}
\tcbuselibrary{minted,breakable,xparse,skins}

\definecolor{bg}{gray}{0.95}
\DeclareTCBListing{mintedbox}{O{}m!O{}}{%
  breakable=true,
  listing engine=minted,
  listing only,
  minted language=#2,
  minted style=default,
  minted options={%
    linenos,
    gobble=0,
    breaklines=true,
    breakafter=,,
    fontsize=\small,
    numbersep=8pt,
    #1},
  boxsep=0pt,
  left skip=0pt,
  right skip=0pt,
  left=25pt,
  right=0pt,
  top=3pt,
  bottom=3pt,
  arc=5pt,
  leftrule=0pt,
  rightrule=0pt,
  bottomrule=2pt,
  toprule=2pt,
  colback=bg,
  colframe=orange!70,
  enhanced,
  overlay={%
    \begin{tcbclipinterior}
    \fill[orange!20!white] (frame.south west) rectangle ([xshift=20pt]frame.north west);
    \end{tcbclipinterior}},
  #3}

\usepackage[europeanresistors, americaninductors]{circuitikz}
\DeclareMathOperator{\sgn}{\mathop{sgn}}
\newcommand*{\hm}[1]{#1\nobreak\discretionary{}
	{\hbox{$\mathsurround=0pt #1$}}{}}


\title{\textbf{Вопрос по выбору. Моделирование полостей Роша, оценка плотностей темных гало.}}
\author{Маслаков Иван}





\begin{document}

\begin{center}
\Huge
\vspace{2cm}
\textbf{Квантовая коррекция ошибок}
\vspace{2cm}
\end{center}

\section{Операторы Паули}



\subsection{№1}


1) Пусть оператор Паули на $n$ кубитах имеет вид $P = P_1 \otimes ... \otimes P_n$.

2) Пусть $\ket{\psi_i}$ - собственный вектор для $P_i$, отвечающий собственному значению $\lambda_i$. Тогда $\ket{\psi} = \ket{\psi_1} \otimes ... \otimes \ket{\psi_n}$ - собственный для $P$, отвечающий собственному значению $\lambda = \lambda_1 \cdot ... \cdot \lambda_n$.

3) Заметим, что каждый $P_i$ обладает собственными значениями $+1$ и $-1$, а набор собственных для $P$ векторов, полученный как тензорные произведения векторов $\ket{\psi_i}$ будет иметь размерность $2^n$, тк на i-ую позицию можно выбрать один из двух собственных векторов для $P_i$. Причем полученный набор векторов $\ket{\psi}$ будет независимым, тк $\ket{\psi_i}$ независимы, а все собственные вектора для $P_i$ отличаются выбором $\ket{\psi_i}$ хотя бы для одного i.

4) Таким образом все $\lambda$ является произведение $k_+$ единиц и $k_-$ минус единиц, где $k_+$ - число выбранных $\ket{\psi_i}$, отвечающих собственному значению $+1$, а $k_-$ - число $\ket{\psi_i}$, отвечающих $-1$.

5) Тогда все $\lambda = \pm 1$, причем {-1} среди них $C_{n}^{[\frac{n}{2}]}$, то есть столько же, сколько и {+1}.


\subsection{№2}


 1) Пусть даны операторы Паули $P = P_1 \otimes ... \otimes P_n$ и $Q = Q_1 \otimes ... \otimes Q_n$.

2) Известное правило Кронекера: $(A \otimes B)  (C \otimes D) = (AC) \otimes (BD)$ по индукции легко обобщается как: $PQ = (P_1 Q_1) \otimes ... \otimes (P_n Q_n)$.

3) Заметим, что все матрицы Паули, очевидно, коммутируют сами с собой и с единичной I. А пары типа $\sigma_i \sigma_j$ антикоммутируют при $i \neq j$.

4) Поскольку константу $-1$ из тензорного произведения $(P_1 Q_1) \otimes ... \otimes (P_n Q_n)$ можно вынести, то $PQ = (-1)^k QP$, $k$ - число позиций i в разложении $P$ и $Q$ в тензорные произведения, где стоят несовпадающие матрицы Паули (пары типа$\sigma_i \sigma_j$ где $i \neq j$).

5) Соответственно при $k \scalebox{0.75}{\vdots} 2$ операторы $P$ и $Q$ коммутируют, иначе - антикоммутируют.


\subsection{Некоторые соображения относительно стабилизаторов}


1) Пусть $S \subset G_n$ - подгруппа группы Паули. $S$ стабилизирует $V_s$ - некое множество состояний $n$ кубитов, если каждый вектор $v$ из $V_s$ не меняется под действием любого оператора из $S$, то есть $V_s$ является общим $+1$ собственным подпространством для всех операторов из $S$.

2) Пусть $V_s$ стабилизируется подгруппой $S$, подействуем на пространство кет-векторов унитарным оператором $U$. Тогда $U(V_s)$ стабилизируется $\langle U g_1 U^\dag, ... , U g_l U^\dag \rangle$, где $g_i$ - образующие  $S$, то есть $S = \langle g_1, ... , g_l \rangle$. Это верно тк раз $g \ket{\psi} = \ket{\psi}$, то $U \ket{\psi} = U g \ket{\psi}$, а значит и $U \ket{\psi} = U g U^\dag U\ket{\psi}$, потому что $U U^\dag = I$.


\subsection{№3}


0) Будем пользоваться тем, что для системы независимых операторов $\{ g_1, ..., g_k\}$ и каждого $i$ от $1$ до $k$ существует $r_i$ такое, что $r_i$ коммутирует со всеми $g_j$ при $i \neq j$ и антикоммутирует с $g_i$. Доказательство этого утверждения с использованием проверочной матрицы приведено ниже (утверждение $10.4$):

\begin{center}
	\includegraphics[width=15cm]{dv.jpg}
\end{center}


1) Рассмотрим следующие операторы на $n$ кубитах: $P_x = 2 ^ {-k} \cdot \prod\limits_{j = 1}^k (I + (-1)^{x_j} \cdot g_j)$, где $x$ - последовательность нулей и единиц длины $k$.

2) Заметим, что $\frac{(I + g_i)}{2}$ - проектор на собственное $+1$ подпространство $g_i$. Для того, чтобы в этом убедится рассмотрим разложение произвольного кет-вектора на по базису из собственных векторов для $g_i$ $\ket{\psi} = \ket{\psi_+} + \ket{\psi_-}$, где $\ket{\psi_+}$ - сумма проекций на базисные векторы, отвечающие значению $+1$, а $\ket{\psi_+}$ - сумма проекций на базисные векторы, отвечающие значению $+1$, а $\ket{\psi_-}$ - сумма проекций на базисные векторы, отвечающие значению $-1$. Тогда:

\vspace{0.2cm}

$\frac{(I + g_i)}{2} \ket{\psi} = \frac{\ket{\psi_+} + \ket{\psi_-}}{2} + \frac{\ket{\psi_+} - \ket{\psi_-}}{2} = \ket{\psi_+}$

\vspace{0.2cm}

Аналогично, $\frac{(I - g_i)}{2}$ - проектор  на собственное $-1$ подпространство $g_i$.

3) Заметим, что $P_0$ $(x = 00...0)$- проектор на искомое $V_s$ - общее собственное $+1$ подпространство для всех $g_i$, то есть $P_0(H^n) = V_s$ тк вектор последовательно проецируются на все собственные подпространства в результате применения данного оператора.

4) Заметим, что из пункта 0) следует существование такого $g_x \subset G_n$, что $g_x P_x g_x^\dag = P_0$. Таким $g_x$ является произведение $g_x = \prod r_i$ с такими номерами $i$, на которых в последовательности $x$ стоят единицы. Действительно, пусть на $i$-ом месте в последовательности $x$ стоит единица, раскроем скобки в выражении для $r_i P_x r_i^\dag$

\begin{equation}
    r_i P_x r_i^\dag = [r_i I r_i^\dag] +
\end{equation}
\begin{equation}
    + [r_i (-1)^{x_1} g_1 r_i^\dag + ... + r_i (-1)^{x_k} g_k r_i^\dag] +
\end{equation}
\begin{equation}
    + [r_i (-1)^{x_1} (-1)^{x_2} g_1 g_2 r_i^\dag + ... + r_i (-1)^{x_k} (-1)^{x_{k-1}} g_k g_{k-1} r_i^\dag] +
\end{equation}
\begin{equation}
    + ... +
\end{equation}
\begin{equation}
    + [r_i (-1)^{x_1}...(-1)^{x_k} g_1 ... g_k r_i^\dag]
\end{equation}

В каждом слагаемом начнем премещать $r_i$ вправо, пользуясь тем что этот оператор коммутирует с $g_j, j \neq i$ и антикоммутирует с $g_i$. Тк $r_i r_i^\dag = I$, то все слагаемые остануться прежними, но перед теми что включали в себя $g_i$ поменяется знак, тк мы поменяли местами антикоммутирующие операторы. Свернем скобки обратно и заметим, что изменился лишь знак перед $g_i$ в соответствующем сомножителе $\frac{(I + (-1)^{x_i + 1} \cdot g_i)}{2}$. Таким образом заменив нечетные степени $-1$ на четные во всех множителях путем последовательного применения $r_j$-х мы получим оператор $P_0$.

5) Тот факт, что каждый $P_x = g_x^\dag P_0 g_x$, а $g_x$ - ортогональное преобразование, позволяет утверждать, что $\dim(P_0(H^n)) = \dim(P_x(H^n))$.

6) Наконец, заметим, что пространства $P_x(H^n)$ и $P_y(H^n)$ ортогональны при $x \neq y$ (то есть $x$ и $y$ отличаются в некоторой позиции $i$), тогда тк собственные $+1$ и $-1$ подпространства $g_i$ ортогональны, то их подпространства ортогональны. Тогда после применения $i$-ого сомножителя $P_x$ и $P_y$ мы уже получим ортогональные подпространства.

7) $\oplus_x P_x(H^n) = H^n$ (каждый n-кубитный базисный вектор оставит в этой сумме как свою положительную так и отрицательную проекцию в каждом кубите). Тогда в силу равенства размерностей всех $P_x(H^n)$ и в частности $V_s$ можем утверждать что $\dim V_s = \frac{\dim H^n}{2 ^ k}$, тк всего имеется $2^k$ слагаемых.

8) То есть $\dim V_s = 2 ^ {n - k}$.


\subsection{№4}


1) $\ket{0} ^ {\otimes n}$ - состояние стабилизатора, потому что подгруппа $\langle Z_1, ... , Z_n \rangle$ его не меняет, где $Z_i = I ^ {\otimes (i - 1)} \otimes Z \otimes I ^ {\otimes (n - i)}$, тк вектор $\ket{0}$ лежит на оси $O_z$.

2) $\ket{0} ^ {\otimes n} + \ket{1} ^ {\otimes n}$ - состояние стабилизатора, потому что подгруппа $\langle X_1, ... , X_n \rangle$ его не меняет, тк вектор $\ket{0} + \ket{1}$ лежит на оси $O_x$.

*) второй пункт можно доказать и пользуясь 2) соображением о стабилизаторах, потому что если подействовать элементом Адамара на Гильбертово пространство, то окажется, что $\ket{0}$ переходит в $\ket{0} + \ket{1}$, а $HZH^\dag = X$.


\subsection{№5}


Гейты Клиффорда - гейты, преобразующие операторы Паули в другие операторы Паули. Проверим это для $CNOT, S, H, T$:

\begin{center}
	\includegraphics[width=5cm]{t1.jpg}
\end{center}

Мы видим, что $CNOT, S, H$ являются гейтами Клиффорда.

\vspace{0.2cm}

Однако $T$ не является гейтом Клиффорда, тк $TXT^\dag = \frac{(X + Y)}{\sqrt{2}}$.

\vspace{1.5cm}

\section{Теорема Готесмана-Нилла}



\subsection{Формулировка}


Квантовая схема, использующая только следующие элементы, может быть эффективно смоделирована на классическом компьютере:

1. Подготовка кубитов в вычислительных базисных состояниях

2. Гейты Клиффорда (гейт Адамара, гейт CNOT, фазовые гейт S )

3. Измерения в вычислительном базисе.

\subsection{Идея}

Идея, лежащая в остнове данного утверждения следующая: на классическом компьютере можно описать квантовую схему, состоящую из вышеперечисленных элементов, описанных в формализме стабилизаторов. Для описания состояния системы указывается набор образующих пространства операторов, стабилизирующих это состояние. Действие оператора $U$ на данное состояние описывается как изменение соответствующих образующих ($UgU^\dag$).

Так как состояние n-кубитной системы описывается n образующими (в свою очередь состоящими из n элементарных матриц), то для того, чтобы промоделировать схему из m элементов потребуется классический алгоритм сложности $O(n^2m)$.

\section{Декомпозиция элемента n-кубитного элемента Тоффоли}

\subsection{Общее описание и требования к квантовому процессору}

Для описания я выбрал тот способ декомпозиции, про который услышал впервые. Декомпозиция элемента $C^{n-1}X$ при помощи кудитов и операций над ними (как мы увидим в последствие всего одной) состоит из $2n - 3$ элементарных элементов, то есть ее сложность линейна от числа управляющих кубитов.

Итак, для начала отметим, что классическое n-кубитное пространство состояний будет рассматриваться как подпространство n-кудитного пространства состояний (то есть у обычных кубитов мы рассматриваем несколько дополнительных уровней). Достоинством данной декомпозиции является то, что дополнительные уровни кубитов используются в роли анцилл для хранения информации, а значит не требуется привлечение дополнительных физических систем (кубитов) для выполнения этой функции.

Для выдвижения требования к процессору, на котором возможна реализация декомпозиции, воспользуемся понятием связующего графа $E$. В нем вершины, являющиеся кудитами (кубитами), соединены ребром, если над ними возможно произведение операции $CZ$. Из данного графа путем, например, обхода в глубину (имеющего сложность $O(v + r)$, где $v$ - число вершин графа, $r$ - число ребер) выделим оставное дерево. Утверждается, что данную декоспозицию можно реализовать, если в этом дереве количество соседей каждой вершины $s_i$ связано с количеством используемых уровней $d_i$ кудита , соответствующего этой вершине, следующим соотношением: $d_i > s_i$.

Так же потребуем возможность произведения операции $X_i^{Q_j}$ над кубитом $Q_j$, которая действует следующим образом: $X_d \ket{0}^{Q_j} = \ket{d}^{Q_j}, X_d \ket{d}^{Q_j} = \ket{0}^{Q_j}$ и никак не меняет прочие состояния.

\subsection{Реализация декомпозиции}

Заметим, что для реализации элемента $C^(n-1)X_i$, то есть с конкретным целевым кудитом среди данных $n$, достаточно выполнить преобразование следующее преобразование над этими кудитами: $H_iC^{n-1}ZH_i = C^(n-1)X_i$, здесь $C^{n-1}Z$ меняет общий фазовый множитель состояния на $-1$, если на вход подается $\ket{1}^n$ и не меняет состояние в ином случае.

Для реализации элемента $CZ$ подвесим дерево за целевой кудит, таким образом оно разобьется на уровне по высоте (уровень, на котором находится вершина определяется количеством ребер, отделяющим ее от корня).

Определим три операции:

1. Сворачивание уровня

2. Основная операция

3. Разворачивание уровня

Сначала производится сварачивание последних уровней, до тех пор, пока дерево не будет состоять всего из 2 уровней. Она заключается в том, что для каждой висячей (на данном этапе) вершине применяется следующая последовательность преобразований:

а) К родительской вершине применяется $X_{i+1}$, где $i$ - номер данной висячей вершины среди дочерних.

б) $CX$ с висячей вершиной в роли управляющего кубита и ее родителем в роли управляемого.

в) $X_1$ над родительской вершиной.

В результате этих операций все вершины предпоследнего уровня переходят в состояние $\ket{1}$ тогда и только тогда, когда все их дочернии вершины были в состоянии $\ket{1}$.

Таким образом после произведения свертки дерева до двух уровней, висячие вершины будут иметь значение $\ket{1}$ тогда и только тогда, когда все вершины на уровнях ниже изначально имели значения $\ket{1}$.

Заметим также, что последовательность этих операций сохраняет состояния вычислительного базиса, а ограничение на размерности кудитов делает ее реализацию возможной.

Основная операция производит такую же свертку предпоследнего уровня и применяет $CZ$ к корню и одному из дочерних кудитов. Соответственно инверсия состояния происходит тогда и только тогда, когда корень находится в состоянии $\ket{1}$, то есть он изначально был в состоянии $\ket{1}$, а также все его дочерние кудиты были в состоянии $\ket{1}$.

Теперь, если мы произведем развертывание, то есть применим все унитарные операторы кроме последнего $CZ$ в обратном порядке, то нетрудно видеть, что инвертированное состояние получится тогда и только тогда, когда все кудиты изначально были в состоянии $\ket{1}$.

Значит мы реализовали элемент $C^{n-1}Z$ а следовательно и $C^{n-1}X_j$. Кроме того, нетрудно подсчитать, что мы использовали не бодее $2n - 3$ кудитных вентиля.

\section{3)	Код из пяти кубитов}

\subsection{№1}

Код из пяти кубитов - $[5, 1]$-код, который, в соответствии с границей Хэмминга невырожденных кодов ($\sum_{j=0}^t C_n^j 3^j 2^k \leq 2^n$, где $t$ - наибольшее количество испорченных кубитов) заействует наименьшее количество кубит, позволяющих задетектировать и исправить любую ошибку Паули в одном из кодирующих кубитов. Таким образом, раз кодируется один кубит, то размерность кодового пространства равна $2$.

\subsection{№2}

Кодовые слова:

\begin{equation}
    \ket{0_L} = \frac{1}{4} (\ket{00000} + \ket{10010} + \ket{01001} + \ket{10100} \ket{01010} - \ket{11011} - \ket{00110} - \ket{11000} - \ket{11101} -
\end{equation}
\begin{equation}
    - \ket{00011} - \ket{11110} - \ket{01111} - \ket{10001} - \ket{01100} - \ket{10111} + \ket{00101})
\end{equation}

Логическая единица $\ket{1_L}$ выглядит так же с точностью до замены $\ket{0}$ на $\ket{1}$ и наоборот.

То есть состояние $\ket{\psi} = a \ket{0} + b \ket{1}$ будет закодировано как $\ket{\psi_L} = a \ket{0_L} + b \ket{1_L}$.

\subsection{№3}

Мы ищем ошибку, измеряя динамические перменные:

$S_1 = XZZXI$

$S_2 = IXZZX$

$S_3 = XIXZZ$

$S_4 = ZXIXZ$

Во-первых такие измерения не дают нам информации о суперпозиции (коэффициентах $a$ и $b$), а значит не разрушают состояния системы. Будем обращать внимание на то, равны ли нулю результаты соответствующих измерений. Например, если ко второму кубиту была применена ошибка паули $X_2$, то ркзультатом измерения $S_1$ будет $\langle \psi_L| X_2^\dag S_1 X_2 | \psi_L \rangle = -1$, аналогично для $\langle \psi_L| X_2^\dag S_2 X_2 | \psi_L \rangle = 1$, $\langle \psi_L| X_2^\dag S_3 X_2 | \psi_L \rangle = 1$, $\langle \psi_L| X_2^\dag S_4 X_2 | \psi_L \rangle = 1$.
Мы получили битовую последовательность длины четыре: 1000. Построим аналогичные последовательности для всех возможных ошибок, в том числе для $IIIII$ (всего $16$ штук). Код для построения последовательностей находится в приложении.

\begin{mintedbox}{python}

import numpy as np

def m(a,b, c, d, e):
   return np.kron(np.kron(np.kron(np.kron(a, b), c), d), e)

z = np.array([1,0])
e = np.array([0,1])

zl = 0.25 * (m(z,z,z,z,z) + m(e,z,z,e,z) + m(z,e,z, z, e)+ m(e,z,e,z,z) + m(z,e,z,e,z)- m(e,e,z,e,e) - m(z,z,e,e,z) - m(e,e,z,z,z) - m(e,e,e,z,e) - m(z,z,z,e,e)- m(e,e,e,e,z) - m(z, e,e,e,e) - m(e,z,z,z,e) - m(z,e,e,z,z) - m(e,z,e,e,e) + m(z,z,e,z,e))
z,e = e,z
el = 0.25 * (m(z,z,z,z,z) + m(e,z,z,e,z) + m(z,e,z, z, e)+ m(e,z,e,z,z)- m(e,e,z,e,e) - m(z,z,e,e,z) - m(e,e,z,z,z) - m(e,e,e,z,e) - m(z,z,z,e,e)- m(e,e,e,e,z) - m(z, e,e,e,e) - m(e,z,z,z,e) - m(z,e,e,z,z) - m(e,z,e,e,e) + m(z,z,e,z,e))
z,e = e,z

X = np.array([[0,1], [1,0]])
Y = np.array([[0,complex(0, -1)],
   [complex(0, 1), 0]])
Z = np.array([[1, 0], [0, -1]])
I = np.array([[1,0], [0,1]])
S1 = m(X,Z,Z,X,I)
S2 = m(I,X,Z,Z,X)
S3 = m(X,I,X,Z,Z)
S4 = m(Z,X,I,X,Z)
psi = zl

error = m(X,X,I,Z,I)

psi_er = np.matmul(error, psi)

bra_pe = np.conj(psi_er)

print(np.matmul(np.matmul(bra_pe, S1), psi_er))
print(np.matmul(np.matmul(bra_pe, S2), psi_er))
print(np.matmul(np.matmul(bra_pe, S3), psi_er))
print(np.matmul(np.matmul(bra_pe, S4), psi_er))
print(zl)
\end{mintedbox}

\vspace{0.5cm}

\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
		\hline
		Ошибка & I & $X_1$ & $X_2$ & $X_3$ & $X_4$ & $X_5$ & $Y_1$ & $Y_2$ & $Y_3$ & $Y_4$ & $Y_5$ \\
		\hline
		Последовательность & 0000 & 0001 & 1000 & 1100 & 0110 & 0011 & 1011 & 1101 & 1110 & 1111 & 0111 \\
		\hline
	\end{tabular}

\vspace{0.2cm}

 \begin{tabular}{|c|c|c|c|c|c|}
		\hline
		Ошибка & $Z_1$ & $Z_2$ & $Z_3$ & $Z_4$ & $Z_5$ \\
		\hline
		Последовательность & 1010 & 0101 & 0010 & 1001 & 0100 \\
		\hline
	\end{tabular}

Таким образом мы научились обнаруживать однокубитовые ошибки Паули, а также определять кубит, в котором они произошли, и их вид. А значит путем применения одноименного с однокубитной ошибкой оператора к состоянию системы мы можем исправить ее.

\subsection{№4}

Используя тот же код, что и в предыдущем пункте, убедимся, что никакая двухкубитная ошибка не может дать последовательность $0000$ после последовательного применения операторов $S_1, S_2, S_3, S_4$. (Полную таблицу приводить не имеет смысла из-за ее размера). Тот факт, что лишь ошибка $I^{\otimes5}$ приводит к результату $0000$, говорит о том, что двухкубитную ошибку мы обнаружить можем, однако не можем исправить, тк определить кубит и сорт ошибки одновременно не представляется возможным, ведь результатов измерений (битовых последовательностей длины $4$) всего $16$ штук, а возможных ошибок - $C_5^2 3^2 = 90$.

\subsection{№5}

Для нахождения трехкубитной ошибки Паули я сделал следующие замечания:

1) Измерение наблюдаемой $S_1$ фактически определяет, были ли (не одновременно!) произведины операции $X_1$ и $X_4$ или $Z_2$ и $Z_3$. Аналогично и с измерениями других наблюдаемых.

2) Начертим два графа, в которых вершины - кубиты, а ребра соединяют вершины, одновременность ошибок в которых проверяется той или иной наблюдаемой (см. фотографию).

\begin{center}
	\includegraphics[width=10cm]{graph.jpg}
\end{center}

3) Для получения результата $0000$ после измерения четырех наблюдаемых нужно выбрать такую трехкубитную ошибку Паули, которая для каждого измерения, то есть пары одинаково подписанных ребер, будет иметь в вершине каждого ребра одноименные вершины (одноименные - если ни к одной из или к обем была применена соответствующая графу ошибка. Разноименные, если соответствующая графу ошибка была применена только к одной из вершин. На фото у вершин к которым применялась ошибка стоят обозначения).

4) Например из соображений симметрии картинки напрашиваются варианты выбора вершин: $1, 4, 2$ или $5, 4, 3$ и соответсвующие им ошибки $X, Z, X$ или $Z, X, Z$.

Проверим, например, вариант ошибки $X_1 X_2 Z_4$ используя упомянутый выше код. Действительно, результат измерения наблюдаемых будет $0000$, то есть такой же, как в случае отсутствия ошибки, а значит трехкубитную ошибку Паули $X_1 X_2 Z_4$ мы задетектировать не сможем.

\section{9-ти кубитовый код Шора}

\subsection{Введение}

Для начала упомянем 3-х кубитовый коды для исправления классических и фазовых ошибок.

3-х кубитовый код, исправляющий классические ошибки  очень похож на 5-ти кубитовый, описанный выше. Он кодирует состояние $\ket{\psi} = a\ket{0} + b\ket{1}$ как $\ket{\psi_L} = a\ket{000} + b\ket{111}$. А измеряемые наблюдаемые - это $Z_1 Z_2$ , $Z_2 Z_3$, $X_1 X_2$, $X_2 X_3$ и $Y_1 Y_2$. Легко видеть, построив таблицу или граф аналогичные тем, что приведены для 5-ти кубитового кода, что 3-х кубитовый код исправляет произвольную однокубитовую ошибку Паули.

Теперь зададимся вопросом, как можно исправить фазовую ошибку в одном кубите, то есть ошибку, меняющую состояния кубита с $\ket{\psi} = a\ket{0} + b\ket{1}$ на $\ket{\psi`} = a\ket{0} - b\ket{1}$. Заметим, что фазовая ошибка "переворачивает" базис Адамара, то есть преобразует $\ket{+}$ в $\ket{-}$ и наоборот. Это означает, что фазовая ошибка действует в базисе Адамара так же, как классическая в вычислительном базисе. А это означает, что исправление фазовой ошибки можно произвести тем же способом, что и классической, используя следующий логический базис: $\ket{0_L} = \ket{+++}$ и $\ket{1_L} = \ket{---}$. При этом измерять нужно следующие наблюдаемые: $H^{\otimes 3} Z_1 Z_2 H^{\otimes 3} = X_1 X_2$ и.т.д.

\subsection{Код Шора (№1, №2, №3)}


Код Шора - код исправления ошибок, способный боороться одновременно и с классической и с фазовой ошибкой в одном кубите, построенный на основе двух вышеописанных 3-х кубитовых кодов.

Сначала применяется кодировка кубита, исправляющая фазовую ошибку:
$\ket{0}$ превращается в $ \ket{+++}$ и $\ket{1} $ в $ \ket{---}$.

Приведем схему, производящую такое кодирование:

\begin{center}
	\includegraphics[width=10cm]{sh_h_sh_c.jpg}
\end{center}

Затем каждый кубит кодируется кодовыми словами, исправляющими классическую ошибку,

\vspace{0.2cm}

то есть $\ket{+} \rightarrow \frac{\ket{0} + \ket{1}}{\sqrt{2}}$ и $\ket{-} \rightarrow \frac{\ket{0} - \ket{1}}{\sqrt{2}}$.

Соответственно получаются кодовые слова:

\vspace{0.2cm}

$\ket{0_L} = (\frac{\ket{000} + \ket{111}}{\sqrt{2}}) ^ {\otimes 3}$

\vspace{0.2cm}

$\ket{1_L} = (\frac{\ket{000} - \ket{111}}{\sqrt{2}}) ^ {\otimes 3}$

\vspace{0.2cm}

Заметим, что последовательное измерение сначала наблюдаемых, отвечающих фазовой ошибки, позволит ее исправить, а измерение наблюдаемых, отвечающих классической ошибке, предотвратит и ее.

\subsection{Произвольная ошибка}

Теперь покажем, что возможно исправить произвольную ошибку в одном кубите:

Пусть в результате ошибки состояние $\ket{\psi_L} = a \ket{0_L} + b \ket{1_L} \rightarrow \sum_{i = 1}^9 \E_i \ket{\psi_L} \bra{\psi_L} E_i^\dag$

Рассмотрим ошибку, действующую на один кубит $E_i = I + a_1 X_i + a_2 Z_i + a_3 X_i Z_i$, значит состоянние $E_i \ket{\psi}$ - есть суперпозиция состояний $X_i \ket{\psi}$, $Z_i \ket{\psi}$, $X_i Z_i \ket{\psi}$ и после измерения синдрома система придет в одно из этих состояний, а его, как мы показали ранее код Шора может исправить.

Таким образом код Шора исправляет произвольную ошибку в одном кубите. Его $X_L = (H^\dag X H) ^ {\otimes 9} = Z ^ {\otimes 9}$, переводящий $\ket{0}$ в $\ket{1}$ и $Z_L = (H^\dag Z H) ^ {\otimes 9} = X ^ {\otimes 9}$. При этом набор стабилизаторов кода - комбинации стабилизаторов 3-х кубитовых кодов для исправления фазовых и классических ошибок. Я приведу его как слайд из лекции Дэниэла Готтесмана:

\begin{center}
	\includegraphics[width=10cm]{stb.jpg}
\end{center}

\section{Известные ошибки, украденные кубиты и самый маленький код}

\subsection{№1}

Невозможность исправления ошибки весом $[\frac{d-1}{2}]$ означает, что существуют две ошибки Паули $E_1$ и $E_2$ такого или меньшего веса, которые дают одинаковые битовые строки при измерении наблюдаемых $S_1, S_2, ..., S_{n-k}$, то есть коммутируют и антикоммутируют с одинаковыми набороми этих наблюдаемых. Такие ошибки неотличимы друг от друга с точки зрения нашего кода. Рассмотрим ошибку $E = E_1 E_2$ заметим, что тк наборы наблюдаемых, с которыми $E_1$ и $E_2$ коммутируют и антикоммутируют совпадают, то $E$ коммутирует со всеми наблюдаемыми, а значит в результате измерений даст полностью нулевую битовую строку. Тк вес ошибки $E$ меньше либо равен суммы весов ошибок $E_1$ и $E_2$, то он меньше либо равен $d-1$. По определению кода такую ошибку мы можем обнаружить, значит полностью нулевая битовая строка как результат измерений говорит о том, что $E =\alpha I^{\otimes n}$. А это в свою очередь говорит о том, что $E_1 = E_2$, мы пришли к противоречию.
Значит такой код способен исправить ошибки весом не более $[\frac{d-1}{2}]$.

\subsection{№2}

Невозможность исправить (отличить друг от друга) ошибки Паули $E_1$ и $E_2$ весом $d-1$ означает, что эти ошибки, во-первых, действуют на одни и те же кубиты (иначе бы их отличили по этому дополнительному признаку), а во-вторых, после измерений дают одинаковые битовые последовательности, то есть, опять же, коммутирую и антикоммутируют с одинаковыми наборами наблюдаемых. Рассмотрим $E = E_1 E_2$. Вес этой ошибки равен весу $E_1$ (или $E_2$), то есть не превосходит $d-1$, потому что $E_1$ и $E_2$ действуют на одни и те же биты. Как и в предыдущем пункте из-за совпадения наборов коммутирующих и антикоммутирующих стабилизаторов для $E_1$ и $E_2$, ошибка $E$ коммутирует со всеми операторами, а раз по определению она может быть обнаружена, то $E = \alpha I^{\otimes n}$ и $E_1 = E_2$. Значит мы пришли к противоречию и любая ошибка Паули весом менее $d$ может быть исправлена данным кодом при дополнительном условии известности "испорченных" кубитов.

\subsection{№3}

Пусть украденных кубитов $s \leq d-1$. Заменим эти кубиты на предложенные нам взамен $\ket{0}$ и будем рассматривать полученное состояние как то, которое получилось бы после применения ошибки из пункта $№2$ (позиции на которых стоят потенциально "испорченные" кубиты мы знаем). Как мы показали ранее, такая ошибка может быть исправлена, что в данной ситуации равносильно восстановлению исходного состояния.

\subsection{№4}

\begin{center}
\Huge
\vspace{2cm}
\textbf{Задания по числовой линейной алгебре}
\vspace{2cm}
\end{center}


\section{Матрица Плотности}

\begin{mintedbox}{python}
import numpy as np

def write_matrix(n):
    matrix = []
    for i in range(n):
        matrix.append([])
        for j in range(n):
            print('element', i, j, ':')
            re, im = [float(_) for _ in input().split()]
            elem = complex(re, im)
            matrix[i].append(elem)
    matrix = np.array(matrix)
    return matrix

def is_pos_def(matrix):
    return np.all(np.linalg.eigvals(matrix) > 0)

def is_er(matrix):
    er_matrix = np.conj(matrix).T
    return np.all((er_matrix - matrix) == 0)

def is_den_matrix(matrix):
    if is_pos_def(matrix) and is_er(matrix) and np.trace(matrix) == 1:
        return True
    return False

print('n:')
n = int(input())
matrix = write_matrix(n)
print(is_den_matrix(matrix))
\end{mintedbox}

\section{Проектор на пространство столбцов}

\begin{mintedbox}{python}
import numpy as np

def write_matrix(n, m):
    matrix = []
    for i in range(n):
        matrix.append([])
        for j in range(m):
            print('element', i, j, ':')
            re, im = [float(_) for _ in input().split()]
            elem = complex(re, im)
            matrix[i].append(elem)
    matrix = np.array(matrix)
    return matrix


def gram_schmidt(vectors):
    num_vectors = len(vectors)
    ortho_basis = np.zeros_like(vectors)

    for i in range(num_vectors):
        ortho_basis[i] = vectors[i]
        for j in range(i):
            ortho_basis[i] -= np.dot(vectors[i], ortho_basis[j]) / np.dot(ortho_basis[j], ortho_basis[j]) * ortho_basis[
                j]
        ortho_basis[i] /= np.linalg.norm(ortho_basis[i])

    return ortho_basis

def Px(ONB, vector):
    projection = np.zeros_like(vector)
    projection_old = np.zeros_like(vector)
    for i in range(len(ONB)):
        projection = projection + np.dot(vector, ONB[i]) * ONB[i]
        #projection_old = projection_old +
    return projection

def projector(matrix, vector):
    U, s, V = np.linalg.svd(matrix)
    E = np.diag(s)
    mtrx = np.matmul(U, E)
    basis = mtrx.T[np.nonzero(s)[0]]
    ONB = gram_schmidt(basis)
    onb = list(ONB)
    l = len(ONB[0])
    while(len(onb) < l):
        onb.append(np.zeros_like(ONB[0]))
    onb = np.array(onb)
    return Px(ONB, vector).T, onb @ np.conj(onb.T)

print('n:')
#n = int(input())
n = 4
print('m:')
#m = int(input())
m = 4
#matrix = write_matrix(n, m)
matrix = np.array([[1+0j, 0+1j],
          [0+1j, 1+0j],
          [0+0j, 0+0j]])
matrix = np.array([[1, 0, 0, 0],
          [0, 2, 0, 0],
          [0, 3, 0, 0],
          [0, 0, 0, 1]])
vector = np.array([1, 1, 1, 1])
ans, proj = projector(matrix, vector)
print(ans)
print(proj)
\end{mintedbox}


\begin{center}
\Huge
\vspace{2cm}
\textbf{Квантовая информация и вычислительные задачи}
\vspace{2cm}
\end{center}

\section{Чистые и смешанные состояния}

Для того чтобы отличить два этих источника, проведем серии измерений для большого числа частиц порожденных одним и другим источником в базисе Адамара.

Первый источник создает системы $\frac{1}{\sqrt{2}}(\ket{0} + \ket{1})$ значит вероятность получить состояние $\ket{+}$ при измерении $P_1 = 1$ (базисное состояние прибора совпадает с измеряемым).

Второй источник ($\frac{1}{2} (|0 \rangle \langle 0| + |1 \rangle \langle 1|)$) порождает системы с матрицей плотности:

\begin{center}
$\rho_2 = \frac{1}{2}$
\begin{pmatrix}
1 & 0\\
0 & 1
\end{pmatrix}
\end{center}

И соответственно вероятность обнаружения системы в состоянии $\ket{+}$ такова: $P_2 = \langle + | \rho_2 | + \rangle = \frac{1}{2}$.

Таким образом в серии измерений первого источника мы всегда будем получать состояние $\ket{+}$, а в серии измерений второго источника состояние $\ket{+}$ будет получаться только в половине случаев.

\section{Сфера Блоха}

Сфера Блоха - геометрическая интерпритация состояний кубита. Рассмотрим произвольное чистое состояние кубита $\ket{\psi} = \alpha \ket{0} + \beta \ket{1}$ и однозначно сопоставим ему точку на единичной сфере:

\begin{center}
    $\ket{\psi} = a e^{i \sigma} \ket{0} + b e^{i \phi} \ket{1}$ ($a^2 + b^2 = 1$)
\end{center}

Отбрасывая общий фазовый множитель и переобознаяая $a$ и $b$:

\begin{center}
    $\ket{\psi} = \cos{\frac{\theta}{2} \ket{0} + \sin{\frac{\theta}{2} e^{i(\phi - \sigma)}\ket{1}}}$
\end{center}

Полярный и азимутальный углы $\frac{\theta}{2}$ и $\phi - \sigma$ задают координаты на единичной сфере, а значит мы определили биекцию между множествам состояний кубита и точками на единичной сфере.

\begin{center}
	\includegraphics[width=7cm]{bloch.jpg}
\end{center}

\section{Матрицы умножения}

После действия операторов $UUI$ и $IVV$ на систему с матрицей плотности $\rho_a \otimes \rho_b \otimes \rho_c$ мы получим состояние со следующей матрицей плотности:

$\rho` = (U \rho_a U^\dag) \otimes (V U \rho_b U^\dag V^\dag) \otimes (V \rho_c V^\dag)$

Для выделения матрицы частицы $C$ из матрицы плотности всей системы воспользуемся операция взятия частичного следа по состояниям частицы $A$ и $B$:

$\rho_c` = Tr_{A B}(\rho`) = Tr_{A B}((U \rho_a U^\dag) \otimes (V U \rho_b U^\dag V^\dag) \otimes (V \rho_c V^\dag))$

\section{Максимально запутанные состояния}

\begin{equation}
    \ket{\psi} = \frac{1}{\sqrt{2}} (\ket{00} + \ket{11})
\end{equation}
\begin{equation}
    U \otimes U^* \ket{\psi} = \frac{1}{\sqrt{2}} (U \otimes U^* \ket{00} + U \otimes U^* \ket{11}) =
\end{equation}
\begin{equation}
    = \frac{1}{\sqrt{2}} (U \ket{0} \otimes U^*\ket{0} + U \ket{1} \otimes U^* \ket{1}) = [\text{при } U = \begin{pmatrix}
a & b\\
c & d
\end{pmatrix}] =
\end{equation}
\begin{equation}
    = \frac{1}{\sqrt{2}} (\begin{pmatrix}
a & b\\
c & d
\end{pmatrix} \begin{pmatrix}
1\\
0
\end{pmatrix} \otimes \begin{pmatrix}
a^* & b^*\\
c^* & d^*
\end{pmatrix} \begin{pmatrix}
1\\
0
\end{pmatrix} + \begin{pmatrix}
a & b\\
c & d
\end{pmatrix} \begin{pmatrix}
0\\
1
\end{pmatrix} \otimes \begin{pmatrix}
a^* & b^*\\
c^* & d^*
\end{pmatrix} \begin{pmatrix}
0\\
1
\end{pmatrix}) =
\end{equation}
\begin{equation}
    = \frac{1}{\sqrt{2}} (\begin{pmatrix}
a\\
c
\end{pmatrix} \otimes \begin{pmatrix}
a^*\\
c^*
\end{pmatrix} + \begin{pmatrix}
b\\
d
\end{pmatrix} \otimes \begin{pmatrix}
b^*\\
d^*
\end{pmatrix}) =
\end{equation}
\begin{equation}
    = \frac{1}{\sqrt{2}} \begin{pmatrix}
aa^* + bb^*\\
ac^* + bd^*\\
ca^* + db^*\\
cc^* + dd^*
\end{pmatrix} =
\end{equation}
\begin{equation}
    = [\text{тк } I = UU^\dag = \begin{pmatrix}
a & b\\
c & d
\end{pmatrix} \begin{pmatrix}
a^* & c^*\\
b^* & d^*
\end{pmatrix} = \begin{pmatrix}
1 & 0\\
0 & 1
\end{pmatrix}] = \frac{1}{\sqrt{2}}(\begin{pmatrix}
1\\
0\\
0\\
0
\end{pmatrix} + \begin{pmatrix}
0\\
0\\
0\\
1
\end{pmatrix} )= \frac{1}{\sqrt{2}} (\ket{00} + \ket{11}) = \ket{\psi}
\end{equation}

\section{Реализация квантового алгоритма. Алгоритм Гровера}

\begin{mintedbox}{python}
import matplotlib.pyplot as plt
import numpy as np
import math

from qiskit import IBMQ, Aer, transpile, execute
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister
from qiskit.quantum_info import Operator

from qiskit.visualization import plot_histogram


n = 4
grover_circuit = QuantumCircuit(n)

def f(x):
    if x == 2:
        return 1
    return 0


def initialize_s(qc, qubits):
    """Apply a H-gate to 'qubits' in qc"""
    for q in qubits:
        qc.h(q)
    return qc

grover_circuit = initialize_s(grover_circuit, range(n))

def create_diffusion(qc, qubits):
    print(qubits)
    qc.h(qubits)
    qc.x(qubits)
    qc.h(qubits[-1])
    length = len(qubits)
    if length > 3:
        qc.mct(qubits[0:-1], qubits[-1])
    elif length == 3:
        qc.toffoli(qubits[0:-1], qubits[2])
    elif length == 2:
        qc.cx(qubits[0], qubits[1])
    qc.h(qubits[-1])
    qc.x(qubits)
    qc.h(qubits)

    return qc



def create_oracle(qc, f, n):
    matrix = np.eye(2 ** n)
    for i in range(2 ** n):
        matrix[i][i] = (-1) ** f(i)
    oracle = Operator(matrix)
    print(matrix)

    return oracle

matrix = np.eye(2 ** n)
for i in range(2 ** n):
    matrix[i][i] = (-1) ** f(i)
oracle = Operator(matrix)



reapit = int(np.pi / 4 * 2 ** (n / 2))
#reapit = 0

for _ in range(reapit):
    grover_circuit.append(oracle, [_ for _ in range(n)])
    grover_circuit = create_diffusion(grover_circuit, [_ for _ in range(n)])

sv_sim = Aer.get_backend('statevector_simulator')
result = sv_sim.run(grover_circuit).result()
statevec = result.get_statevector()
from qiskit.visualization import array_to_latex
array_to_latex(statevec, prefix="|\\psi\\rangle =")

grover_circuit.measure_all()

qasm_sim = Aer.get_backend('qasm_simulator')
result = qasm_sim.run(grover_circuit).result()
counts = result.get_counts()
plt.hist(counts)
plt.show()

grover_circuit.draw()
\end{mintedbox}

\begin{center}
	\includegraphics[width=10cm]{output.png}
\end{center}

\begin{center}
	\includegraphics[width=15cm]{sh.jpg}
\end{center}

\end{document}